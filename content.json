{"meta":{"title":"Xdh129's Hexo","subtitle":null,"description":null,"author":"Xdh129","url":"https://xdh129.github.io","root":"/"},"pages":[],"posts":[{"title":"PTA拼题网作业-算法_动态规划-1207","slug":"Algorithm-Learning-OnLine-Homework-201207","date":"2020-12-07T11:45:02.000Z","updated":"2020-12-07T11:45:02.000Z","comments":true,"path":"2020/12/07/Algorithm-Learning-OnLine-Homework-201207/","link":"","permalink":"https://xdh129.github.io/2020/12/07/Algorithm-Learning-OnLine-Homework-201207/","excerpt":"","text":"最大子段和 给定n个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。当所给的整数均为负数时，定义子段和为0。 要求算法的时间复杂度为O(n)。 输入格式: 输入有两行： 第一行是n值（1&lt;=n&lt;=10000)； 第二行是n个整数。 输出格式: 输出最大子段和。 输入样例: 在这里给出一组输入。例如： 6-2 11 -4 13 -5 -2 输出样例: 在这里给出相应的输出。例如： 20 程序代码:123456789101112131415161718192021#include &lt;stdio.h&gt;int main() &#123; int n, max = 0, current = 0; scanf(\"%d\", &amp;n); for (int k = 0; k &lt; n; ++k) &#123; int temp; scanf(\"%d\", &amp;temp); current += temp; if (current &gt; max) &#123; max = current; &#125; if (current &lt; 0) &#123; current = 0; &#125; &#125; printf(\"%d\\n\", max); return 0;&#125; 运行截图: 运行截图 0-1背包 给定n(n&lt;=100)种物品和一个背包。物品i的重量是wi，价值为vi，背包的容量为C(C&lt;=1000)。问:应如何选择装入背包中的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品i只有两个选择：装入或不装入。不能将物品i装入多次，也不能只装入部分物品i。 输入格式: 共有n+1行输入： 第一行为n值和c值，表示n件物品和背包容量c； 接下来的n行，每行有两个数据，分别表示第i(1≤i≤n)件物品的重量和价值。 输出格式: 输出装入背包中物品的最大总价值。 输入样例: 在这里给出一组输入。例如： 5 102 62 36 55 44 6 输出样例: 在这里给出相应的输出。例如： 15 程序代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#define N 105int main() &#123; int n, c; scanf(\"%d %d\", &amp;n, &amp;c); int itemWeights[N], itemValues[N], dp[N][10 * N], temp[N] = &#123;0&#125;; for (int k = 1; k &lt;= n; ++k) &#123; scanf(\"%d %d\", &amp;itemWeights[k], &amp;itemValues[k]); &#125; for (int k = 0; k &lt;= c; ++k) &#123; if (k &lt; itemWeights[n]) &#123; dp[n][k] = 0; &#125; else &#123; dp[n][k] = itemValues[n]; &#125; &#125; for (int i = n - 1; i &gt;= 1; --i) &#123; for (int j = 0; j &lt;= c; ++j) &#123; if (j &gt;= itemWeights[i] &amp;&amp; dp[i + 1][j] &lt; dp[i + 1][j - itemWeights[i]] + itemValues[i]) &#123; dp[i][j] = dp[i + 1][j - itemWeights[i]] + itemValues[i]; &#125; else &#123; dp[i][j] = dp[i + 1][j]; &#125; &#125; &#125; int cv = 0; for (int k = 1; k &lt;= n - 1; ++k) &#123; if (dp[k][c] != dp[k + 1][c]) &#123; temp[k] = 1; cv += itemValues[k]; &#125; &#125; if (dp[1][c] &gt;= cv) &#123; temp[n] = 1; &#125; printf(\"%d\\n\", dp[1][c]); return 0;&#125; 运行截图: 运行截图 回文串问题 一个字符串，如果从左到右读和从右到左读是完全一样的，比如”aba”，我们称其为回文串。现在给你一个字符串，可在任意位置添加字符，求最少添加几个字符，才能使其变成一个回文串。 输入格式: 任意给定的一个字符串，其长度不超过1000. 输出格式: 能变成回文串所需添加的最少字符数。 输入样例: 在这里给出一组输入。例如： Ab3bd Abb 输出样例: 在这里给出相应的输出。例如： 2 1 程序代码:123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;memory.h&gt;#include &lt;string.h&gt;#define N 1001#define max(a, b) ((a)&gt;(b)?(a):(b))char str[N];int dp[N][N];int main() &#123; memset(dp, 0, sizeof(dp)); char str1[1001]; while (gets(str) != NULL) &#123; int len = strlen(str); int temp = len - 1; for (int k = 0; k &lt; len; ++k) &#123; str1[temp--] = str[k]; &#125; for (int i = 1; i &lt;= len; ++i) &#123; for (int j = 1; j &lt;= len; ++j) if (str[i - 1] == str1[j - 1]) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1); &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; printf(\"%d\\n\", len - dp[len][len]); &#125; return 0;&#125; 运行截图: 运行截图 矩阵链相乘问题4.矩阵的乘法定义如下：设A是m×p的矩阵，B是p×n的矩阵，则A与B的乘积为m×n的矩阵，记作C=AB，其中，矩阵C中的第i行第j列元素c​ij​​可以表示为：c​ij​​=Σ​k=1​p​​a​ik​​×b​kj​​=a​i1​​b​1j​​+a​i2​​b​2j​​+⋯+a​ip​​b​pj​​. 当多个矩阵相乘时，采用不同的计算顺序所需的乘法次数不相同。例如，A是50×10的矩阵，B是10×20的矩阵，C是20×5的矩阵， 计算ABC有两种方式：(AB)C和A(BC)，前一种需要15000次乘法计算，后一种则只需3500次。 设A​1​​,A​2​​,…,A​n​​为矩阵序列，A​i​​是阶为P​i−1​​∗P​i​​的矩阵(1≤i≤n)。试确定矩阵的乘法顺序，使得计算A​1​​A​2​​…A​n​​过程中元素相乘的总次数最少。 输入格式: 每个输入文件为一个测试用例，每个测试用例的第一行给出一个正整数n(1≤n≤100)，表示一共有n个矩阵A​1​​,A​2​​,…,A​n​​，第二行给出n+1个整数P​0​​,P​1​​…P​n​​，以空格分隔，其中1≤P​i​​≤100(0≤i≤n)，第i个矩阵A​i​​是阶为P​i−1​​∗P​i​​的矩阵。 输出格式: 获得上述矩阵的乘积，所需的最少乘法次数。 输入样例: 在这里给出一组输入。例如： 530 35 15 5 10 20 输出样例: 在这里给出相应的输出。例如： 11875 程序代码:12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#define N 2001long long dp[N][N];int arr[N + 1][2];int main() &#123; int n; scanf(\"%d\", &amp;n); scanf(\"%d\", &amp;arr[1][0]); for (int k = 1; k &lt;= n; ++k) &#123; if (k &gt; 1) &#123; arr[k][0] = arr[k - 1][1]; &#125; scanf(\"%d\", &amp;arr[k][1]); &#125; for (int i = n; i &gt;= 1; --i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; if (j == i + 1) &#123; dp[i][j] = arr[i][0] * arr[i][1] * arr[j][1]; &#125; for (int k = i; k &lt; j; ++k) &#123; int num = dp[k + 1][j] + dp[i][k] + arr[i][0] * arr[k][1] * arr[j][1]; if (k == i || num &lt; dp[i][j]) &#123; dp[i][j] = num; &#125; &#125; &#125; &#125; printf(\"%d\\n\", dp[1][n]); return 0;&#125; 运行截图: 运行截图 寻宝 小明有一张藏宝图，上面有m*n个房间，每个房间里面都有一个有一定价值的宝物，小明只能从左上角的房间进入收集宝物，且每次只能向右边或向下边的房间继续寻宝，最终只能从最右下的房间出来。请你帮小明计算下他最多可以收集到多少价值的宝物？ 输入格式: 输入第一行给出两个正整数m,n(1=&lt;m,n&lt;=2000)，随后给出m行数据，每行都包括n个正整数，中间用空格分割。 输出格式: 输出收集到的最大价值v，题目保证v&lt;10^9。 输入样例: 4 41 18 9 37 10 6 125 13 4 152 11 8 16 输出样例: 78 程序代码:12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define N 2001int dp[N][N];int main() &#123; int m, n; scanf(\"%d %d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; scanf(\"%d\", &amp;dp[i][j]); &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (dp[i - 1][j] &gt; dp[i][j - 1]) &#123; dp[i][j] = dp[i][j] + dp[i - 1][j]; &#125; else &#123; dp[i][j] = dp[i][j] + dp[i][j - 1]; &#125; &#125; &#125; printf(\"%d\\n\", dp[m][n]); return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"算法设计实验6-动态规划算法-1207","slug":"Algorithm-Learning-Homework-201207","date":"2020-12-07T11:03:13.000Z","updated":"2020-12-07T11:03:13.000Z","comments":true,"path":"2020/12/07/Algorithm-Learning-Homework-201207/","link":"","permalink":"https://xdh129.github.io/2020/12/07/Algorithm-Learning-Homework-201207/","excerpt":"","text":"最长公共子序列问题 最长公共子序列问题。问题描述：若给定序列X={x1,x2,…,xm}，则另一序列Z={z1,z2,…,zk}，是X的子序列是指存在一个严格递增下标序列{i1,i2,…,ik}使得对于所有j=1,2,…,k有：zj=xij。例如，序列Z={B，C，D，B}是序列X={A，B，C，B，D，A，B}的子序列，相应的递增下标序列为{2，3，5，7}。给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。给定2个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}，找出X和Y的最长公共子序列。在参考程序的基础上，编写主函数，实现最长公共子序列的动态规划求解。测试数据包括教材155页算法设计题中给出的数据，另外再自己设计两组测试数据。 程序代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 100void LCSLength(char *x, char *y, int m, int n, int c[][N], int b[][N]) &#123; for (int k = 0; k &lt;= m; ++k) &#123; c[k][0] = 0; &#125; for (int k = 1; k &lt;= n; ++k) &#123; c[0][k] = 0; &#125; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (x[i - 1] == y[j - 1]) &#123; c[i][j] = c[i - 1][j - 1] + 1; b[i][j] = 1; &#125; else if (c[i - 1][j] &gt;= c[i][j - 1]) &#123; c[i][j] = c[i - 1][j]; b[i][j] = 2; &#125; else &#123; c[i][j] = c[i][j - 1]; b[i][j] = 3; &#125; &#125; &#125;&#125;void PrintLCS(int b[][N], char *x, int i, int j) &#123; if (i == 0 || j == 0) &#123; return; &#125; if (b[i][j] == 1) &#123; PrintLCS(b, x, i - 1, j - 1); printf(\"%c\", x[i - 1]); &#125; else if (b[i][j] == 2) &#123; PrintLCS(b, x, i - 1, j); &#125; else &#123; PrintLCS(b, x, i, j - 1); &#125;&#125;int main() &#123; char x[N], y[N]; int m, n, b[N][N], c[N][N]; while (1) &#123; gets(x); gets(y); m = strlen(x); n = strlen(y); LCSLength(x, y, m, n, c, b); PrintLCS(b, x, m, n); printf(\"\\n\"); &#125; return 0;&#125; 运行截图: 运行截图 计算矩阵连乘积 计算矩阵连乘积。问题描述：在科学计算中经常要计算矩阵的乘积。矩阵A和B可乘的条件是矩阵A的列数等于矩阵B的行数。若A是一个p×q的矩阵，B是一个q×r的矩阵，则其乘积C=AB是一个p×r的矩阵。由该公式知计算C=AB总共需要pqr次的数乘。其标准计算公式为： 标准计算公式 现在的问题是，给定n个矩阵{A1,A2,…,An}。其中Ai与Ai+1是可乘的，i=1,2,…,n-1。要求计算出这n个矩阵的连乘积A1A2…An，最少的乘法次数。递归公式： 递归公式 请编写程序实现矩阵连乘问题的动态规划算法，自己设计不少于3组的测试数据，要求显示出最少的乘法次数，以及最优计算次序。 程序代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100void MatrixChain(int *p, int n, int *m, int *s) &#123; for (int a = 0; a &lt; N; ++a) &#123; for (int b = 0; b &lt; N; ++b) &#123; *(m + a * N + b) = rand(); *(s + a * N + b) = rand(); &#125; &#125; for (int a = 2; a &lt;= n; ++a) &#123; for (int b = 1; b &lt;= n - a + 1; ++b) &#123; int temp = b + a - 1; *(m + b * N + temp) = *(m + (b + 1) * N + temp) + *(p + b - 1) * *(p + b) * *(p + temp); *(s + b * N + temp) = b; for (int c = b + 1; c &lt; temp; ++c) &#123; int t = *(m + b * N + c) + *(m + (c + 1) * N + temp) + *(p + b - 1) * *(p + c) * *(p + temp); if (t &lt; *(m + b * N + temp)) &#123; *(m + b * N + temp) = t; *(s + b * N + temp) = c; &#125; &#125; &#125; &#125;&#125;void TraceBack(int i, int j, int *s) &#123; if (i == j) &#123; printf(\"A[%d]\", i); return; &#125; printf(\"(\"); TraceBack(i, *(s + i * N + j), s); TraceBack(*(s + i * N + j) + 1, j, s); printf(\")\");&#125;int main() &#123; int n, p[N], m[N][N], s[N][N]; int *mP = m[0], *sP = s[0]; printf(\"请输入矩阵的个数n:\\n\"); scanf(\"%d\", &amp;n); printf(\"请依次输入每个矩阵的行数和最后一个矩阵的列数：\\n\"); for (int k = 0; k &lt;= n; ++k) &#123; scanf(\"%d\", &amp;p[k]); &#125; MatrixChain(p, n, mP, sP); printf(\"TraceBack:\"); TraceBack(1, n, sP); printf(\"\\n最少的乘法次数：%d\\n\", m[1][n]); return 0;&#125; 运行截图: 运行截图1 运行截图2 运行截图3 最大子段和 最大子段和。问题描述：给定由n个整数（可能有负整数）组成的序列（a1,a2,…,an），最大子段和问题要求该序列形如ak(k=1,…,n)的最大值（1&lt;=i&lt;=j&lt;=n），当序列中所有整数均为负整数时，其最大子段和为0。 1） 用分治法求解。（选做） 程序代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 1000int maxSum(int low, int high, int *nums) &#123; int mid, max = 0, leftMax = 0, rightMax = 0, mLeftMax = 0, mRightMax = 0, leftTemp = 0, rightTemp = 0; if (low == high) &#123; if (nums[low] &gt; 0) &#123; max = nums[low]; &#125; else &#123; max = 0; &#125; &#125; if (low &lt; high) &#123; mid = (low + high) / 2; leftMax = maxSum(low, mid, nums); rightMax = maxSum(mid + 1, high, nums); for (int k = mid; k &gt;= low; --k) &#123; leftTemp += nums[k]; if (mLeftMax &lt; leftTemp) &#123; mLeftMax = leftTemp; &#125; &#125; for (int k = mid + 1; k &lt;= high; ++k) &#123; rightTemp += nums[k]; if (mRightMax &lt; rightTemp) &#123; mRightMax = rightTemp; &#125; &#125; max = mLeftMax + mRightMax; &#125; if (max &lt; rightMax) &#123; max = rightMax; &#125; if (max &lt; leftMax) &#123; max = leftMax; &#125; return max;&#125;int main() &#123; int n, num[N]; scanf(\"%d\", &amp;n); memset(num, 0, sizeof(num)); for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%d\", &amp;num[k]); &#125; printf(\"%d\\n\", maxSum(0, n - 1, num)); return 0;&#125; 运行截图: 运行截图 2） 用动态规划法求解。 程序代码:123456789101112131415161718192021#include &lt;stdio.h&gt;int main() &#123; int n, max = 0, current = 0; scanf(\"%d\", &amp;n); for (int k = 0; k &lt; n; ++k) &#123; int temp; scanf(\"%d\", &amp;temp); current += temp; if (current &gt; max) &#123; max = current; &#125; if (current &lt; 0) &#123; current = 0; &#125; &#125; printf(\"%d\\n\", max); return 0;&#125; 运行截图: 运行截图 最大k乘积问题 最大k乘积问题。问题描述：设X是一个n位十进制整数，如果将X划分为K段，则可得到K个整数，这K个整数的乘积称为X的一个K乘积。请设计算法并编程实现，对于给定的X 和K，求出X的最大K乘积。输入：X，K，n输出：X的最大K乘积。 程序代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#define N 51#define K 10long arr[K][N] = &#123;&#123;0, 0&#125;&#125;;long tempArr[N][N] = &#123;&#123;0, 0&#125;&#125;;void dp(int n, int k, int *a) &#123; long temp, max; for (int k = 1; k &lt;= n; ++k) &#123; arr[k][1] = tempArr[1][k]; &#125; for (int a = 1; a &lt;= n; ++a) &#123; for (int b = 2; b &lt;= k; ++b) &#123; if (a &gt;= b) &#123; max = 0; for (int c = 1; c &lt; a; ++c) &#123; if ((temp = arr[c][b - 1] * tempArr[c + 1][a]) &gt; max) &#123; max = temp; &#125; &#125; arr[a][b] = max; &#125; &#125; &#125;&#125;int main() &#123; int x, k, n[N] = &#123;0&#125;, nCount = 0; scanf(\"%d %d \", &amp;x, &amp;k); for (int k = 0; k &lt; x; ++k) &#123; char temp = getchar(); n[++nCount] = temp - '0'; &#125; for (int i = 1; i &lt;= x; ++i) &#123; tempArr[i][i] = n[i]; for (int j = i + 1; j &lt;= x; ++j) &#123; tempArr[i][j] = tempArr[i][j - 1] * 10 + n[j]; &#125; &#125; dp(x, k, n); printf(\"%ld\\n\", arr[x][k]); return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"PTA拼题网作业-算法_回溯-1130","slug":"Algorithm-Learning-OnLine-Homework-201130","date":"2020-11-30T12:15:02.000Z","updated":"2020-11-30T12:15:02.000Z","comments":true,"path":"2020/11/30/Algorithm-Learning-OnLine-Homework-201130/","link":"","permalink":"https://xdh129.github.io/2020/11/30/Algorithm-Learning-OnLine-Homework-201130/","excerpt":"","text":"最佳调度问题 假设有n（n&lt;=20）个任务由k（k&lt;=20）个可并行工作的机器完成。完成任务i需要的时间为ti。 试设计一个算法，对任意给定的整数n和k，以及完成任务i 需要的时间为ti ，i=1~n。计算完成这n个任务的最佳调度，使得完成全部任务的时间最早。输入格式: 输入数据的第一行有2 个正整数n和k。第2 行的n个正整数是完成n个任务需要的时间。输出格式: 将计算出的完成全部任务的最早时间输出到屏幕。输入样例: 在这里给出一组输入。例如： 7 32 14 4 16 6 5 3 输出样例: 在这里给出相应的输出。例如： 17 程序代码:123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int tasks[20], taskR[20], min = 99;void backTrace(int x, int n, int kn) &#123; if (x == n) &#123; int max = taskR[0]; for (int k = 1; k &lt;= kn; ++k) &#123; if (taskR[k] &gt; max) &#123; max = taskR[k]; &#125; &#125; if (max &lt; min) &#123; min = max; &#125; return; &#125; for (int k = 0; k &lt; kn; ++k) &#123; if (taskR[k] + tasks[x] &gt; min) &#123; continue; &#125; taskR[k] += tasks[x]; backTrace(x + 1, n, kn); taskR[k] -= tasks[x]; &#125;&#125;int main() &#123; int n, kn; scanf(\"%d %d\", &amp;n, &amp;kn); for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%d\", &amp;tasks[k]); &#125; for (int k = 0; k &lt; kn; ++k) &#123; taskR[k] = 0; &#125; backTrace(0, n, kn); printf(\"%d\\n\", min); return 0;&#125; 运行截图: 运行截图 八皇后问题 在国际象棋中，皇后是最厉害的棋子，可以横走、直走，还可以斜走。棋手马克斯·贝瑟尔 1848 年提出著名的八皇后问题：即在 8 × 8 的棋盘上摆放八个皇后，使其不能互相攻击 —— 即任意两个皇后都不能处于同一行、同一列或同一条斜线上。例如： 题图 现在我们把棋盘扩展到 n×n 的棋盘上摆放 n 个皇后，请问该怎么摆？ 请编写程序，输入正整数 n，输出全部摆法（棋盘格子空白处显示句点“.”，皇后处显示字母“Q”，每两个字符之间空一格）。输入格式 正整数 n(n&gt;0) 输出格式 若问题有解，则输出全部摆法（每两种摆法之间空一行）。 若问题无解，则输出 None。 要求：试探的顺序按从上到下逐行进行，其中每一行按从左到右的逐格进行，请参看输出样例2。 输入样例1 3 输出样例1 None 输入样例2 6 输出样例2 . Q . . . .. . . Q . .. . . . . QQ . . . . .. . Q . . .. . . . Q . . . Q . . .. . . . . Q. Q . . . .. . . . Q .Q . . . . .. . . Q . . . . . Q . .Q . . . . .. . . . Q .. Q . . . .. . . . . Q. . Q . . . . . . . Q .. . Q . . .Q . . . . .. . . . . Q. . . Q . .. Q . . . . 程序代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;int n, flag = 0;int f(int x, int y, char a[][1000]) &#123; int x1, y1 = y, m; for (int k = y - 1; k &gt;= 0; --k) &#123; x1 = 0, y1 = k; m = y - y1; while (a[y1][x1] != 'Q') x1++; if (x1 == x) return 0; if (x1 - m == x || x1 + m == x) return 0; &#125; return 1;&#125;int s(int x, char a[][1000]) &#123; if (x == n) &#123; if (flag) &#123; printf(\"\\n\"); &#125; flag = 1; for (int i = 0; i &lt; x; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (a[i][j] == 'Q') &#123; printf(\"%c\", a[i][j]); &#125; else &#123; printf(\".\"); &#125; if (j != n - 1) &#123; printf(\" \"); &#125; &#125; printf(\"\\n\"); &#125; return 0; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (f(j, x, a)) &#123; a[x][j] = 'Q'; s(x + 1, a); a[x][j] = '.'; &#125; &#125; return 1;&#125;int main() &#123; scanf(\"%d\", &amp;n); char a[1000][1000]; s(0, a); if (flag == 0) &#123; printf(\"None\\n\"); &#125; return 0;&#125; 运行截图: 运行截图 0-1背包 给定n(n&lt;=100)种物品和一个背包。物品i的重量是wi，价值为vi，背包的容量为C(C&lt;=1000)。问:应如何选择装入背包中的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品i只有两个选择：装入或不装入。不能将物品i装入多次，也不能只装入部分物品i。输入格式: 共有n+1行输入： 第一行为n值和c值，表示n件物品和背包容量c； 接下来的n行，每行有两个数据，分别表示第i(1≤i≤n)件物品的重量和价值。 输出格式: 输出装入背包中物品的最大总价值。 输入样例: 在这里给出一组输入。例如： 5 102 62 36 55 44 6 输出样例: 在这里给出相应的输出。例如： 15 程序代码:12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define max(a, b) ((a)&gt;(b)?(a):(b))int main() &#123; int n, c; scanf(\"%d %d\", &amp;n, &amp;c); int itemWeights[n + 1], itemValues[n + 1], dp[105][1005]; for (int k = 1; k &lt;= n; ++k) &#123; scanf(\"%d %d\", &amp;itemWeights[k], &amp;itemValues[k]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= c; ++j) &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= itemWeights[i]) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - itemWeights[i]] + itemValues[i]); &#125; &#125; &#125; printf(\"%d\\n\", dp[n][c]); return 0;&#125; 运行截图: 运行截图 整数拆分4.将一个正整数拆分成若干个正整数的和。输入格式: 一个正整数n输出格式: 若干行，每行一个等式（每个数或者等号间都有一个空格，第一个数前没有空格，最后一个数后面没有空格，数与数之间要求非降序排列）。最后一行给出解的总个数输入样例: 在这里给出一组输入。例如： 4 输出样例: 在这里给出相应的输出。例如： 4 = 1 + 1 + 1 + 14 = 1 + 1 + 24 = 1 + 34 = 2 + 24 程序代码:123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int n = 0, count = 0, dp[1001] = &#123;1&#125;;void dfs(int num, int x) &#123; if (num == 0) &#123; printf(\"%d = \", n); for (int k = 1; k &lt; x - 1; ++k) &#123; printf(\"%d + \", dp[k]); &#125; printf(\"%d\\n\", dp[x - 1]); ++count; return; &#125; else &#123; for (int k = dp[x - 1]; k &lt;= num; ++k) &#123; if (k &lt; n) &#123; dp[x] = k; num -= k; dfs(num, x + 1); num += k; &#125; &#125; &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); dfs(n, 1); printf(\"%d\\n\", count); return 0;&#125; 运行截图: 运行截图 666 小明有一张m*n的好习惯记录卡，记录每一天的好习惯目标达成度（数字0-9表示）。某天目标完成达成，就在当天的格子里写上数字6，目标没有完全达成就写上一个小于6的数字（0-5），目标超额完成就写上一个大于6的数字（7-9）。记录卡上如果能找到一条长度为3的路径并且路径上的三个数字都大于等于6（这里的路径是指从某个格子出发，可以向左、右、上、下格子移动，并且不能重复经过一个格子），则小明就能得到一个“666”奖励。请你帮小明统计下他总共能得到多少“666”奖励。 输入格式: 输入第一行给出两个正整数m,n(1=&lt;m,n&lt;=100),随后是m行，每行包含n个0-9之间的数字。输出格式: 先输出m行，每行包括n个整数，代表从当前格子出发得到的“666”奖励个数，中间用空格分割，最后一个数字后面不带空格。然后再在下一行输出得到的“666”奖励总数。 输入样例: 3 36 6 73 8 37 9 5 输出样例: 2 1 20 3 01 1 010 程序代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;int arrayS[4][2] = &#123;&#123;1, 0&#125;,&#123;0, 1&#125;,&#123;-1, 0&#125;,&#123;0, -1&#125;&#125;;int dpArray[102][102];int habitArray[102][102];int dfs(int x, int y, int m, int n, int step) &#123; if (step &gt;= 3) &#123; return 1; &#125; else &#123; int temp = 0; for (int i = 0; i &lt; 4; ++i) &#123; int posX = x + arrayS[i][0], posY = y + arrayS[i][1]; if (posY &gt;= 0 &amp;&amp; posX &gt;= 0 &amp;&amp; posY &lt; n &amp;&amp; posX &lt; m &amp;&amp; dpArray[posX][posY] != 1) &#123; dpArray[posX][posY] = 1; if (habitArray[posX][posY] &gt;= 6) &#123; temp += dfs(posX, posY, m, n, step + 1); &#125; dpArray[posX][posY] = 0; &#125; &#125; return temp; &#125;&#125;int main() &#123; int m, n, count = 0; scanf(\"%d %d\", &amp;m, &amp;n); for (int i = 0; i &lt; m; ++i)&#123; for (int j = 0; j &lt; n; ++j)&#123; scanf(\"%d\", &amp;habitArray[i][j]); &#125; &#125; for (int i = 0; i &lt; m; ++i)&#123; for (int j = 0; j &lt; n; ++j) &#123; dpArray[i][j] = 1; int num = 0; if (habitArray[i][j] &gt;= 6)&#123; num = dfs(i, j, m, n, 1); &#125; dpArray[i][j] = 0; count += num; printf(\"%d\", num); if (j == n - 1) &#123; printf(\"\\n\"); &#125; else &#123; printf(\" \"); &#125; &#125; &#125; printf(\"%d\\n\", count); return 0;&#125; 运行截图: 运行截图 工作分配问题 设有n件工作分配给n个人。将工作i分配给第j个人所需的费用为cij 。 设计一个算法，对于给定的工作费用，为每一个人都分配1 件不同的工作，并使总费用达到最小。 输入格式: 输入数据的第一行有1 个正整数n (1≤n≤20)。接下来的n行，每行n个数，表示工作费用。 输出格式: 将计算出的最小总费用输出到屏幕。 输入样例: 在这里给出一组输入。例如： 310 2 32 3 43 4 5 输出样例: 在这里给出相应的输出。例如： 9 程序代码:123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;int workers[22], resultArray[22][22], min = 9999;void dfs(int x, int n, int cost) &#123; if (x == n) &#123; if (cost &lt; min) &#123; min = cost; &#125; &#125; else &#123; for (int k = 0; k &lt; n; ++k) &#123; cost += resultArray[x][k]; if (workers[k] != 1 &amp;&amp; cost &lt; min) &#123; workers[k] = 1; dfs(x + 1, n, cost); workers[k] = 0; &#125; cost -= resultArray[x][k]; &#125; &#125;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;resultArray[i][j]); &#125; &#125; dfs(0, n, 0); printf(\"%d\\n\", min); return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"算法设计实验5-回溯-1130","slug":"Algorithm-Learning-Homework-201130","date":"2020-11-30T11:15:53.000Z","updated":"2020-11-30T11:15:53.000Z","comments":true,"path":"2020/11/30/Algorithm-Learning-Homework-201130/","link":"","permalink":"https://xdh129.github.io/2020/11/30/Algorithm-Learning-Homework-201130/","excerpt":"","text":"整数变换问题 整数变换问题。问题描述：整数i的两种变换定义为 ， （向下取整）；设计一个算法求给定两个整数a和b，用最少次数的 和 变换将整数a变换为b；例如实现提示：观察f和g两个操作可知，f总是使得i变大，g总是使得i变小。因此在决定让x执行哪个操作之前可以先判断i和目标值m之间的大小关系。如果x&gt;m，就让其执行g操作；反之，执行f操作。问题的解分为两种情况，一种是有解，即n可以通过函数变换成m；另一种是无解，即n无法通过函数变换成m。有解的情况比较容易，只需要判断最后的i是否等于m即可。如果i等于m，那么说明n已经被变换成m了，递归返回。无解的情况可用下例分析。假设我们的输入n=9,m=5。n&gt;m,执行g,n=[9/2]=4n&lt;m,执行f,n=34=12n&gt;m,执行g,n=[12/2]=6n&gt;m,执行f,n=[6/2]=3n&lt;m,执行g,n=33=9n&gt;m,执行f,n=[9/2]=4如果n的值陷入了一个重复的循环，如果在递归的过程中，出现了前面计算过的元素，那就说明n是无法转换成m的。这种方法实现稍微复杂，需要判断当前所求出的数值之前是否出现过。 另一种简单的处理方式： 对于m无论如何变换都不能变为n的情况，可以加一个判断条件，比如深度达一个较大值为止（如1000）。回溯法， 用子集树实现，子集树结构为： 子集树结构 回溯返回条件有两个，一个是i等于m，另一个是出现了重复的数字。第二个返回条件可以用一个函数test来判断。剪枝条件：显式约束：如果x&gt;m，就剪掉它的左子树；如果x&lt;m，就剪掉它的右子树；隐式约束：如果在某次计算的过程中发现当前的计算次数已经大于或等于最少计算次数了，那么就剪掉这个分支。 程序代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;int count, foundFlag;int f(int i) &#123; return 3 * i;&#125;int g(int i) &#123; return i / 2;&#125;int transform(int m, int n, int a, int b, int *num) &#123; int s; if (m &gt; count) &#123; return 0; &#125; for (int k = 0; k &lt; 2; ++k) &#123; s = n; if (k == 0) &#123; s = g(s); &#125; else &#123; s = f(s); &#125; num[m] = k; if (s == b || transform(m + 1, s, a, b, num)) &#123; foundFlag = 1; return 1; &#125; &#125; return 0;&#125;void compare(int a, int b, int *num) &#123; count = 1; foundFlag = 0; while (!transform(1, a, a, b, num)) &#123; ++count; if (count &gt; 100) &#123; break; &#125; if (foundFlag != 0) &#123; break; &#125; &#125;&#125;int main() &#123; int a, b, num[100]; for (int k = 0; k &lt; 100; ++k) &#123; num[k] = 0; &#125; printf(\"请依次输入a和b的值: \"); scanf(\"%d %d\", &amp;a, &amp;b); compare(a, b, num); if (foundFlag) &#123; printf(\"运算次数为: %d\\n\", count); printf(\"运算转换过程为: \"); for (int k = count; k &gt;= 1; --k) &#123; if (num[k] == 0) &#123; printf(\"g\"); &#125; if (num[k] == 1) &#123; printf(\"f\"); &#125; &#125; &#125; else &#123; printf(\"%d 无法转换成%d \\n\", a, b); &#125; return 0;&#125; 运行截图: 运行截图 子集和问题 子集和问题。问题描述：给定集合S，S中有n个正整数，M是一个正整数。子集和问题判定是否存在S的一个子集S1，使得S1中各元素之和等于M。请设计回溯法求解子集和问题，如果问题无解，输出“No Solution”,问题有解，则输出满足子集S1中各元素的值。 程序代码:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int flag, a[10005], rec[10005];void dfs(int n, int m, int start, int sum, int cnt) &#123; if (sum &gt; m) &#123; return; &#125; if (sum == m) &#123; for (int k = 0; k &lt; cnt; ++k) &#123; printf(\"%d \", rec[k]); &#125; flag = 1; return; &#125; for (int k = start; k &lt;= n; ++k) &#123; rec[cnt] = a[k]; dfs(n, m, k + 1, sum + a[k], cnt + 1); if (flag) &#123; return; &#125; &#125;&#125;int main() &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; dfs(n, m, 1, 0, 0); if (!flag) &#123; printf(\"No Solution\"); &#125; return 0;&#125; 运行截图: 运行截图 工作分配问题 工作分配问题。问题描述：设有n件工作分配给n个人。将工作i分配给第j个人的费用为cij,请设计算法，为每个人都分配1件不同的工作，并使得总费用达到最小。实现提示：该问题的解空间是一棵排列树，可用搜索排列树的回溯框架实现。 程序代码:123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;int workers[22], resultArray[22][22], min = 9999;void dfs(int x, int n, int cost) &#123; if (x == n) &#123; if (cost &lt; min) &#123; min = cost; &#125; &#125; else &#123; for (int k = 0; k &lt; n; ++k) &#123; cost += resultArray[x][k]; if (workers[k] != 1 &amp;&amp; cost &lt; min) &#123; workers[k] = 1; dfs(x + 1, n, cost); workers[k] = 0; &#125; cost -= resultArray[x][k]; &#125; &#125;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; scanf(\"%d\", &amp;resultArray[i][j]); &#125; &#125; dfs(0, n, 0); printf(\"%d\\n\", min); return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"PTA拼题网作业-算法_贪心算法-1123","slug":"Algorithm-Learning-OnLine-Homework-201123","date":"2020-11-24T12:15:02.000Z","updated":"2020-11-24T12:15:02.000Z","comments":true,"path":"2020/11/24/Algorithm-Learning-OnLine-Homework-201123/","link":"","permalink":"https://xdh129.github.io/2020/11/24/Algorithm-Learning-OnLine-Homework-201123/","excerpt":"","text":"装箱问题 假设有N项物品，大小分别为s​1​​、s​2​​、…、s​i​​、…、s​N​​，其中s​i​​为满足1≤s​i​​≤100的整数。要把这些物品装入到容量为100的一批箱子（序号1-N）中。装箱方法是：对每项物品, 顺序扫描箱子，把该物品放入足以能够容下它的第一个箱子中。请写一个程序模拟这种装箱过程，并输出每个物品所在的箱子序号，以及放置全部物品所需的箱子数目。 输入格式： 输入第一行给出物品个数N（≤1000）；第二行给出N个正整数s​i​​（1≤s​i​​≤100，表示第i项物品的大小）。 输出格式： 按照输入顺序输出每个物品的大小及其所在的箱子序号，每个物品占1行，最后一行输出所需的箱子数目。 输入样例： 860 70 80 90 30 40 10 20 输出样例： 60 170 280 390 430 140 510 120 25 程序代码:12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); int items[n], boxs[n], boxPos[n], boxCount = 0; for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%d\", &amp;items[k]); boxs[k] = 100; &#125; for (int k = 0; k &lt; n; ++k) &#123; int box = 0; while (items[k] &gt; boxs[box]) &#123; ++box; &#125; boxs[box] -= items[k]; boxPos[k] = box; if (boxCount - 1 &lt; box) &#123; boxCount = box + 1; &#125; &#125; for (int k = 0; k &lt; n; ++k) &#123; printf(\"%d %d\\n\", items[k], boxPos[k] + 1); &#125; printf(\"%d\\n\", boxCount); return 0;&#125; 运行截图: 运行截图 月饼 月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。 注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。 输入格式： 每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式： 对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。 输入样例： 3 2018 15 1075 72 45 输出样例： 94.50 程序代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;void InvertedShellSort(int arraySize, double *arrayP, double *anotherArrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; double temp = *(arrayP + j); double anotherTemp = *(anotherArrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &lt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); *(anotherArrayP + k + gap) = *(anotherArrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; *(anotherArrayP + k + gap) = anotherTemp; &#125; &#125; &#125;&#125;int main() &#123; int n; double requestStock; scanf(\"%d %lf\", &amp;n, &amp;requestStock); double mkStock[n], mkPrice[n]; for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%lf\", &amp;mkStock[k]); &#125; for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%lf\", &amp;mkPrice[k]); &#125; double mkUnitPrice[n]; for (int k = 0; k &lt; n; ++k) &#123; mkUnitPrice[k] = (double) mkPrice[k] / mkStock[k]; &#125; InvertedShellSort(n, mkUnitPrice, mkStock); double nextStock = 0.0, requestStocks[n]; for (int i = 0; i &lt; n; ++i) &#123; nextStock += mkStock[i]; if (requestStock &lt;= nextStock) &#123; for (int k = 0; k &lt; i; ++k) &#123; requestStocks[k] = mkStock[k]; &#125; requestStocks[i] = mkStock[i] - (nextStock - requestStock); for (int k = i + 1; k &lt; n; ++k) &#123; requestStocks[k] = 0; &#125; break; &#125; else if (i == n - 1) &#123; for (int k = 0; k &lt; n; ++k) &#123; requestStocks[k] = mkStock[k]; &#125; &#125; &#125; double maxProfit = 0.0; for (int k = 0; k &lt; n; ++k) &#123; maxProfit += mkUnitPrice[k] * requestStocks[k]; &#125; printf(\"%.2lf\\n\", maxProfit); return 0;&#125; 运行截图: 运行截图 最优合并问题 给定k 个排好序的序列, 用 2 路合并算法将这k 个序列合并成一个序列。 假设所采用的 2 路合并算法合并 2 个长度分别为m和n的序列需要m+n-1 次比较。试设 计一个算法确定合并这个序列的最优合并顺序，使所需的总比较次数最少。 为了进行比较，还需要确定合并这个序列的最差合并顺序，使所需的总比较次数最多。 输入格式: 第一行有 1 个正整数k，表示有 k个待合并序列。 第二行有 k个正整数，表示 k个待合并序列的长度。 输出格式: 输出最多比较次数和最少比较次数。 输入样例: 在这里给出一组输入。例如： 45 12 11 2 输出样例: 在这里给出相应的输出。例如： 78 52 题目来源：王晓东《算法设计与分析》 程序代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#define INT_MIN (-INT_MAX - 1)#define INT_MAX __INT_MAX__void ShellSort(int arraySize, int *arrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; int temp = *(arrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &gt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; &#125; &#125; &#125;&#125;void InvertedShellSort(int arraySize, int *arrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; int temp = *(arrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &lt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; &#125; &#125; &#125;&#125;int main() &#123; int n, comparisionCount = 0; scanf(\"%d\", &amp;n); int sequences[n], anotherSequences[n]; for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%d\", &amp;sequences[k]); anotherSequences[k] = sequences[k]; &#125; for (int k = 0; k &lt; n - 1; ++k) &#123; InvertedShellSort(n, anotherSequences); anotherSequences[0] += anotherSequences[1]; comparisionCount += anotherSequences[0] - 1; anotherSequences[1] = INT_MIN; &#125; printf(\"%d \", comparisionCount); comparisionCount = 0; for (int k = 0; k &lt; n - 1; ++k) &#123; ShellSort(n, sequences); sequences[0] += sequences[1]; comparisionCount += sequences[0] - 1; sequences[1] = INT_MAX; &#125; printf(\"%d\\n\", comparisionCount); return 0;&#125; 运行截图: 运行截图 看电影4.终于到周末了，明明是特别喜欢看电影。他想在一天内尽量多的看到完整的多部电影。 现在他把他喜欢的电影的播放时间表给你，希望你能帮他合理安排。 输入格式: 输入包含多组测试数据。每组输入的第一行是一个整数n（n&lt;=100），表示明明喜欢的电影的总数。 接下来n行，每行输入两个整数si和ei（1&lt;=i&lt;=n），表示第i个电影的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。 当n=0时，输入结束。 输出格式: 对于每组输入，输出能完整看到的电影的个数。 输入样例: 在这里给出一组输入。例如： 121 33 40 73 815 1915 2010 158 186 125 104 142 90 输出样例: 在这里给出相应的输出。例如： 5 程序代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;void ShellSort(int arraySize, int *arrayP, int *anotherArrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; int temp = *(arrayP + j); int anotherTemp = *(anotherArrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &gt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); *(anotherArrayP + k + gap) = *(anotherArrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; *(anotherArrayP + k + gap) = anotherTemp; &#125; &#125; &#125;&#125;int main() &#123; int n; while (scanf(\"%d\", &amp;n) &amp;&amp; n) &#123; int si[n], ei[n], count = 0; for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%d %d\", &amp;si[k], &amp;ei[k]); &#125; ShellSort(n, ei, si); int nextEndTime = 0; for (int k = 0; k &lt; n; ++k) &#123; if (si[k] &gt;= nextEndTime) &#123; nextEndTime = ei[k]; ++count; &#125; &#125; printf(\"%d\\n\", count); &#125; return 0;&#125; 运行截图: 运行截图 喷水装置 长L米，宽W米的草坪里装有n个浇灌喷头。每个喷头都装在草坪中心线上（离两边各W/2米）。我们知道每个喷头的位置（离草坪中心线左端的距离），以及它能覆盖到的浇灌范围。 请问：如果要同时浇灌整块草坪，最少需要打开多少个喷头？输入格式: 输入包含若干组测试数据。 第一行一个整数T表示数据组数。 每组数据的第一行是整数n、L和W的值，其中n≤10 000。 接下来的n行，每行包含两个整数，给出一个喷头的位置和浇灌半径。 如图1所示的示意图是样例输入的第一组数据所描述的情况。 喷水装置示例1 输出格式: 对每组测试数据输出一个数字，表示要浇灌整块草坪所需喷头数目的最小值。如果所有喷头都打开还不能浇灌整块草坪，则输出-1。 输入样例: 38 20 25 34 11 27 210 213 316 219 43 10 13 59 36 13 10 15 31 19 1 输出样例: 62-1 数据范围与提示: 对于100%的数据，n≤15000。 程序代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define MAX_NUM 15000typedef struct Sprayer &#123; int position; int radius; double start; double end;&#125; Sprayers[MAX_NUM];int cmp(Sprayer a, Sprayer b) &#123; return a.start &lt; b.start;&#125;int main() &#123; int T; std::cin &gt;&gt; T; Sprayers sprayers; for (int a = 0; a &lt; T; a++) &#123; int n, L, W, count = 0; std::cin &gt;&gt; n &gt;&gt; L &gt;&gt; W; for (int k = 0; k &lt; n; ++k) &#123; std::cin &gt;&gt; sprayers[k].position &gt;&gt; sprayers[k].radius; if (sprayers[k].radius &lt;= W / 2) &#123; continue; &#125; ++count; sprayers[count].start = sprayers[k].position - sqrt(sprayers[k].radius * sprayers[k].radius - W * W / 4.0); sprayers[count].end = sprayers[k].position + sqrt(sprayers[k].radius * sprayers[k].radius - W * W / 4.0); &#125; std::sort(sprayers + 1, sprayers + count + 1, cmp); int minNum = 0, k = 1, flag = 1; double sum = 0; while (sum &lt; L) &#123; ++minNum; double temp = sum; for (; sprayers[k].start &lt;= temp &amp;&amp; k &lt;= count; ++k)// if (sum &lt; sprayers[k].end) &#123; sum = sprayers[k].end; &#125; if (temp == sum &amp;&amp; temp &lt; L) &#123; std::cout &lt;&lt; \"-1\" &lt;&lt; std::endl; flag = 0; break; &#125; &#125; if (flag) &#123; std::cout &lt;&lt; minNum &lt;&lt; std::endl; &#125; &#125; return 0;&#125; 运行截图: 运行截图 活动选择问题 假定一个有n个活动(activity)的集合S={a​1​​,a​2​​,….,a​n​​}，这些活动使用同一个资源（例如同一个阶梯教室），而这个资源在某个时刻只能供一个活动使用。每个活动a​i​​都有一个开始时间s​i​​和一个结束时间f​i​​，其中0&lt;=s​i​​&lt;f​i​​&lt;=32767。如果被选中，任务a​i​​发生在半开时间区间[s​i​​,f​i​​)期间。如果两个活动a​i​​和a​j​​满足[s​i​​,f​i​​)和[s​j​​,f​j​​)不重叠，则称它们是兼容的。也就说，若s​i​​&gt;=f​j​​或s​j​​&gt;=f​i​​，则a​i​​和a​j​​是兼容的。在活动选择问题中，我们希望选出一个最大兼容活动集。 输入格式: 第一行一个整数n(n≤1000)； 接下来的n行，每行两个整数，第一个s​i​​，第二个是f​i​​(0&lt;=s​i​​&lt;f​i​​&lt;=32767)。 输出格式: 输出最多能安排的活动个数。 输入样例: 113 51 412 148 120 68 116 105 73 85 92 13 输出样例: 4 样例解释: 安排的4个活动为1 4, 5 7, 8 11和12 14。 程序代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;void ShellSort(int arraySize, int *arrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; int temp = *(arrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &gt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; &#125; &#125; &#125;&#125;int SelectMinPos(int s, int *tempArrayP) &#123; int index = 0, min = tempArrayP[0]; for (int k = 1; k &lt; s; ++k) &#123; if (min &gt; tempArrayP[k]) &#123; min = tempArrayP[k]; index = k; &#125; &#125; return index;&#125;int GetMinWaitTime(int n, int s, int *tempArrayP, int *waitTimeArrayP) &#123; int sum = 0; for (int k = 0; k &lt; n; ++k) &#123; int index = SelectMinPos(s, tempArrayP); tempArrayP[index] += waitTimeArrayP[k]; sum += tempArrayP[index]; &#125; return sum / n;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); int waitTime[n], temp[n]; for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%d\", &amp;waitTime[k]); temp[k] = 0; &#125; ShellSort(n, waitTime); printf(\"%d\", GetMinWaitTime(n, 1, temp, waitTime)); return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"算法设计实验4-贪心算法-1123","slug":"Algorithm-Learning-Homework-201123","date":"2020-11-24T10:35:02.000Z","updated":"2020-11-24T10:35:02.000Z","comments":true,"path":"2020/11/24/Algorithm-Learning-Homework-201123/","link":"","permalink":"https://xdh129.github.io/2020/11/24/Algorithm-Learning-Homework-201123/","excerpt":"","text":"最优服务次序问题 最优服务次序问题。问题描述：设有n个顾客同时等待一项服务，顾客i需要的服务时间为ti，（1&lt;=i&lt;=n）。应如何安排n个顾客的服务次序才能使平均等待时间达到最小？（平均等待时间是n个顾客等待服务时间总和除以n）输入：第一行为一个正整数n，表示有n个顾客第二行为n个正整数，表示n个顾客需要的服务时间输出：最小平均等待时间。 程序代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;void ShellSort(int arraySize, int *arrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; int temp = *(arrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &gt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; &#125; &#125; &#125;&#125;int SelectMinPos(int s, int *tempArrayP) &#123; int index, min = tempArrayP[0]; for (int k = 1; k &lt; s; ++k) &#123; if (min &gt; tempArrayP[k]) &#123; min = tempArrayP[k]; index = k; &#125; &#125; return index;&#125;int GetMinWaitTime(int n, int s, int *tempArrayP, int *waitTimeArrayP) &#123; int sum = 0; for (int k = 0; k &lt; n; ++k) &#123; int index = SelectMinPos(s, tempArrayP); tempArrayP[index] += waitTimeArrayP[k]; sum += tempArrayP[index]; &#125; return sum / n;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); int waitTime[n], temp[n]; for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%d\", &amp;waitTime[k]); temp[k] = 0; &#125; ShellSort(n, waitTime); printf(\"%d\", GetMinWaitTime(n, 1, temp, waitTime)); return 0;&#125; 运行截图: 运行截图 多处最优服务次序问题 多处最优服务次序问题。问题描述：设有n个顾客同时等待一项服务，顾客i需要的服务时间为ti，（1&lt;=i&lt;=n）。共有s处可以提供此项服务。应如何安排n个顾客的服务次序才能使平均等待时间达到最小？输入：第一行为两个正整数n和s第二行为n个正整数，表示n个顾客需要的服务时间输出：最小平均等待时间。 程序代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt; void ShellSort(int arraySize, int *arrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; int temp = *(arrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &gt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; &#125; &#125; &#125; &#125; int SelectMinPos(int s, int *tempArrayP) &#123; int index = 0, min = tempArrayP[0]; for (int k = 1; k &lt; s; ++k) &#123; if (min &gt; tempArrayP[k]) &#123; min = tempArrayP[k]; index = k; &#125; &#125; return index; &#125; int GetMinWaitTime(int n, int s, int *tempArrayP, int *waitTimeArrayP) &#123; int sum = 0; for (int k = 0; k &lt; n; ++k) &#123; int index = SelectMinPos(s, tempArrayP); tempArrayP[index] += waitTimeArrayP[k]; sum += tempArrayP[index]; &#125; return sum / n; &#125; int main() &#123; int n, s; scanf(\"%d %d\", &amp;n, &amp;s); int waitTime[n], temp[n]; for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%d\", &amp;waitTime[k]); temp[k] = 0; &#125; ShellSort(n, waitTime); printf(\"%d\", GetMinWaitTime(n, s, temp, waitTime)); return 0; &#125; 运行截图: 运行截图 最优分解问题 最优分解问题。问题描述：设n是一个正整数，要求将n分解为若干互不相同的自然数之和，且这些自然数的乘积最大。输入：正整数n输出：计算的最大乘积。如输入10，则输出30.提示：若a+b=const ，则a-b的绝对值越小，ab值越大。贪心策略：将n分成从2开始的连续自然数之和，如果最后剩下一个数，则将此数在后项优先的方式下均匀地分给前面各项。 程序代码:1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); int temp, sum = 0, pos = 0, count = 1, array[n]; for (int k = 2; k &lt;= n; ++k) &#123; array[pos++] = k; sum += k; if (sum &gt; n) &#123; sum -= k; temp = n - sum; --pos; break; &#125; &#125; for (int k = pos - 1; temp; --temp) &#123; ++array[k]; --k; if (k &lt; 0) &#123; k = pos - 1; &#125; &#125; for (int k = 0; k &lt; pos - 1; ++k) &#123; count *= array[k]; &#125; count *= array[pos - 1]; printf(\"%d\", count); return 0;&#125; 运行截图: 运行截图 多机调度问题4.多机调度问题。利用贪心法设计算法求解如下问题：要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。约定，每个作业均可在任何一台机器上加工处理，但未完工前不允许中断处理。作业不能拆分成更小的子作业。这个问题是一个NP完全问题，到目前为止还没有一个有效的解法。对于这一类问题，用贪心选择策略有时可以设计出较好的近似算法。可以考虑以下的贪心策略：（1）最长处理时间作业优先的贪心选择策略。（2）最短处理时间作业优先的贪心选择策略。（3）作业到达时间优先的贪心选择策略。假设7个独立的作业由3台机器加工处理，各作业所需的处理时间为：{2，14，4，6，16，5，3}，写出以上算法求解此问题的结果。 程序代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;memory.h&gt;void ShellSort(int arraySize, int *arrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; int temp = *(arrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &gt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; &#125; &#125; &#125;&#125;void InvertedShellSort(int arraySize, int *arrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; int temp = *(arrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &lt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; &#125; &#125; &#125;&#125;int SelectMinPos(int s, int *tempArrayP) &#123; int index = 0, min = tempArrayP[0]; for (int k = 1; k &lt; s; ++k) &#123; if (min &gt; tempArrayP[k]) &#123; min = tempArrayP[k]; index = k; &#125; &#125; return index;&#125;int GetMinWaitTime(int n, int s, int *tempArrayP, int *waitTimeArrayP) &#123; int sum = 0; for (int k = 0; k &lt; n; ++k) &#123; int index = SelectMinPos(s, tempArrayP); tempArrayP[index] += waitTimeArrayP[k]; sum += tempArrayP[index]; &#125; return sum / n;&#125;int main() &#123; int n = 7, s = 3; //scanf(\"%d %d\", &amp;n, &amp;s); int longWaitTime[] = &#123;2, 14, 4, 6, 16, 5, 3&#125;, shortWaitTime[n], arriveWaitTime[n]; int longWaitTemp[n], shortWaitTemp[n], arriveTemp[n]; memcpy(shortWaitTime, longWaitTime, sizeof(longWaitTime)); memcpy(arriveWaitTime, longWaitTime, sizeof(longWaitTime)); for (int k = 0; k &lt; n; ++k) &#123; //scanf(\"%d\", &amp;longWaitTime[k]); longWaitTemp[k] = 0; shortWaitTemp[k] = 0; arriveTemp[k] = 0; &#125; InvertedShellSort(n, longWaitTime); ShellSort(n, shortWaitTime); printf(\"最长处理时间作业优先的贪心选择策略使用时间为: %d\\n\", GetMinWaitTime(n, s, longWaitTime, longWaitTemp)); printf(\"最短处理时间作业优先的贪心选择策略使用时间为: %d\\n\", GetMinWaitTime(n, s, shortWaitTime, shortWaitTemp)); printf(\"作业到达时间优先的贪心选择策略使用时间为: %d\\n\", GetMinWaitTime(n, s, arriveWaitTime, arriveTemp)); return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"PTA拼题网作业-算法_递归-1116","slug":"Algorithm-Learning-OnLine-Homework-201116","date":"2020-11-16T11:03:41.000Z","updated":"2020-11-17T12:15:06.000Z","comments":true,"path":"2020/11/16/Algorithm-Learning-OnLine-Homework-201116/","link":"","permalink":"https://xdh129.github.io/2020/11/16/Algorithm-Learning-OnLine-Homework-201116/","excerpt":"","text":"递归实现逆序输出整数 本题目要求读入1个正整数n，然后编写递归函数reverse(int n)实现将该正整数逆序输出。 输入格式: 输入在一行中给出1个正整数n。 输出格式: 对每一组输入，在一行中输出n的逆序数。 输入样例: 12345 输出样例: 54321 程序代码:1234567891011121314151617#include &lt;stdio.h&gt;void reverse(int n) &#123; if (n) &#123; printf(\"%d\", n % 10); reverse(n / 10); &#125; else &#123; printf(\"\\n\"); &#125;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); reverse(n); return 0;&#125; 运行截图: 运行截图 二分查找 输入n值(1&lt;=n&lt;=1000)、n个非降序排列的整数以及要查找的数x，使用二分查找算法查找x，输出x所在的下标（0~n-1）及比较次数。若x不存在，输出-1和比较次数。输入格式: 输入共三行： 第一行是n值； 第二行是n个整数； 第三行是x值。输出格式: 输出x所在的下标（0~n-1）及比较次数。若x不存在，输出-1和比较次数。输入样例: 41 2 3 41 输出样例: 02 程序代码:12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;void binarySearch(int target, int arraySize, int intArray[]) &#123; int comparisionCount = 0; int left = 0; int right = arraySize - 1; while (left &lt;= right) &#123; ++comparisionCount; int mid = (right + left) / 2; if (intArray[mid] == target) &#123; printf(\"%d\\n%d\\n\", mid, comparisionCount); return; &#125; else if (intArray[mid] &lt; target) &#123; left = mid + 1; &#125; else if (intArray[mid] &gt; target) &#123; right = mid - 1; &#125; &#125; printf(\"-1\\n%d\\n\", comparisionCount);&#125;int main() &#123; int n, x; scanf(\"%d\", &amp;n); int intArray[n]; for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%d\", &amp;intArray[k]); &#125; scanf(\"%d\", &amp;x); binarySearch(x, n, intArray); return 0;&#125; 运行截图: 运行截图 改写二分搜索算法 设a[0:n-1]是已排好序的数组，请改写二分搜索算法，使得当x不在数组中时，返回小于x的最大元素位置i和大于x的最小元素位置j。当搜索元素在数组中时，i和j相同，均为x在数组中的位置。输入格式: 输入有两行： 第一行是n值和x值； 第二行是n个不相同的整数组成的非降序序列，每个整数之间以空格分隔。输出格式: 输出小于x的最大元素的最大下标i和大于x的最小元素的最小下标j。当搜索元素在数组中时，i和j相同。 提示：若x小于全部数值，则输出：-1 0 若x大于全部数值，则输出：n-1的值 n的值输入样例: 在这里给出一组输入。例如： 6 52 4 6 8 10 12 输出样例: 在这里给出相应的输出。例如： 1 2 题目来源：《计算机算法设计与分析》，王晓东 程序代码:1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;void binarySearch(int target, int arraySize, int intArray[]) &#123; int left = 0; int right = arraySize - 1; while (left &lt;= right) &#123; int mid = (right + left) / 2; if (intArray[mid] == target) &#123; printf(\"%d %d\\n\", mid, mid); return; &#125; else if (intArray[mid] &lt; target) &#123; left = mid + 1; &#125; else if (intArray[mid] &gt; target) &#123; right = mid - 1; &#125; &#125; if (left) &#123; printf(\"%d %d\\n\", right, left); &#125; else &#123; printf(\"-1 0\\n\"); &#125;&#125;int main() &#123; int n, x; scanf(\"%d%d\", &amp;n, &amp;x); int intArray[n]; for (int k = 0; k &lt; n; ++k) &#123; scanf(\"%d\", &amp;intArray[k]); &#125; binarySearch(x, n, intArray); return 0;&#125; 运行截图: 运行截图 分形的递归输出4.分形，具有以非整数维形式充填空间的形态特征。通常被定义为“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”，即具有自相似的性质。 一个盒状分形定义如下： 度为1的盒分形为： X 度为2的盒分形为： 略 依次类推，如果B(n-1)表示n-1度的盒分形，则n度的盒分形递归定义如下： B(n - 1) B(n - 1) B(n - 1) B(n - 1) B(n - 1) 请画出度为n的盒分形的图形 输入格式: 输入一系列度，每行给出一个不大于7的正整数。输入的最后一行以-1表示输入结束 输出格式: 对于每个用例，输出用’X’标记的盒状分形。在每个测试用例后输出包含一个短划线“-”的一行。 输入样例: 1234-1 输出样例: 注意：每行的空格请输出完整。 略 程序代码:12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define MAX 1000void fillFraxArray(int n, int x, int y, char *fraxArray) &#123; if (n == 1) &#123; *(fraxArray + x * MAX + y) = 1; return; &#125; int size = pow(3, n - 2); fillFraxArray(n - 1, x, y, fraxArray); fillFraxArray(n - 1, x + 2 * size, y, fraxArray); fillFraxArray(n - 1, x + size, y + size, fraxArray); fillFraxArray(n - 1, x, y + 2 * size, fraxArray); fillFraxArray(n - 1, x + 2 * size, y + 2 * size, fraxArray);&#125;int main() &#123; int degree, size; char fraxArray[MAX][MAX]; char *fraxArrayP = fraxArray[0]; while (scanf(\"%d\", &amp;degree) &amp;&amp; degree != -1) &#123; fillFraxArray(degree, 1, 1, fraxArrayP); size = pow(3, degree - 1); for (int i = 1; i &lt;= size; ++i) &#123; for (int j = 1; j &lt;= size; ++j) if (fraxArray[i][j]) &#123; printf(\"X\"); &#125; else &#123; printf(\" \"); &#125; printf(\"\\n\"); &#125; printf(\"-\\n\"); &#125; return 0;&#125; 运行截图: 运行截图 棋盘覆盖 在一个2^k * 2^k（k为正整数，k&lt;=10，length=2^k）个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格（其坐标为aa,bb，分别代表行坐标号和列坐标号），以及有四种L型骨牌（如下图）。求用若干块这种L型骨牌实现除该特殊点棋盘的全覆盖。（本题要求采用分治算法做） 棋盘覆盖示例1 棋盘覆盖示例2 输入格式: 输入三个数，分别是aa,bb,length. 输出格式: 输出整个棋盘。其中特殊方格填为0，然后铺棋盘的顺序为：先铺四个子棋盘交界的部分，然后递归的对每个子棋盘按照左上，右上，右下，左下的顺时针顺序铺满棋盘。每一块骨牌中三个方格数字相同，按照顺序标号，即第一块骨牌全标为1，第二块骨牌全标为2，…，以此类推。输出的每个数占4个场宽，右对齐。 输入样例: 1 1 4 表示：特殊格子为（1，1），棋盘有4行4列。 输出样例: 0 2 3 3 2 2 1 3 5 1 1 4 5 5 4 4 表示：先铺三个1（一块L型骨牌），再铺三个2，…，最后铺三个5. 程序代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#define MAX 1024int count = 1;int chessBoardArray[MAX][MAX];void FillChessBoardArray(int tr, int tc, int dr, int dc, int size) &#123; if (size == 1) &#123; return; &#125; int t = count++; int s = size / 2; if (dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123; FillChessBoardArray(tr, tc, dr, dc, s); &#125; else &#123; chessBoardArray[tr + s - 1][tc + s - 1] = t; FillChessBoardArray(tr, tc, tr + s - 1, tc + s - 1, s); &#125; if (dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) &#123; FillChessBoardArray(tr, tc + s, dr, dc, s); &#125; else &#123; chessBoardArray[tr + s - 1][tc + s] = t; FillChessBoardArray(tr, tc + s, tr + s - 1, tc + s, s); &#125; if (dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) &#123; FillChessBoardArray(tr + s, tc + s, dr, dc, s); &#125; else &#123; chessBoardArray[tr + s][tc + s] = t; FillChessBoardArray(tr + s, tc + s, tr + s, tc + s, s); &#125; if (dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) &#123; FillChessBoardArray(tr + s, tc, dr, dc, s); &#125; else &#123; chessBoardArray[tr + s][tc + s - 1] = t; FillChessBoardArray(tr + s, tc, tr + s, tc + s - 1, s); &#125;&#125;int main() &#123; int aa, bb, length; for (int i = 0; i &lt; length; ++i) &#123; for (int j = 0; j &lt; length; ++j) &#123; chessBoardArray[i][j] = 0; &#125; &#125; scanf(\"%d %d %d\", &amp;aa, &amp;bb, &amp;length); FillChessBoardArray(0, 0, aa - 1, bb - 1, length); for (int i = 0; i &lt; length; ++i) &#123; for (int j = 0; j &lt; length; ++j) &#123; printf(\"%4d\", chessBoardArray[i][j]); &#125; printf(\"\\n\"); &#125; return 0;&#125; 运行截图: 运行截图 循环日程表 设有N个选手进行循环比赛，其中N=2​M​​，要求每名选手要与其他N−1名选手都赛一次，每名选手每天比赛一次，循环赛共进行N−1天，要求每天没有选手轮空。输入格式: 输入：M(M&lt;=7)。 输出格式: 输出：表格形式的比赛安排表。一行各数据间用一个空格隔开。 输入样例: 3 输出样例: 在这里给出相应的输出。例如： 1 2 3 4 5 6 7 82 1 4 3 6 5 8 73 4 1 2 7 8 5 64 3 2 1 8 7 6 55 6 7 8 1 2 3 46 5 8 7 2 1 4 37 8 5 6 3 4 1 28 7 6 5 4 3 2 1 说明，第一行为：1 2 3 4 5 6 7 8，1表示本行都是1号选手和其他选手的比赛，如第2个数为2（其下标可以看成1）表示第一天1号和2号比赛，第5个数为5（其下标可以看成4），表示1号和5号在第4天比赛。 程序代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;math.h&gt;void fillArray(int x, int y, int fillSize, int arraySize, int *array) &#123; if (fillSize &gt; 2) &#123; fillArray(x, y, fillSize / 2, arraySize, array); fillArray(x, y + fillSize / 2, fillSize / 2, arraySize, array); &#125; for (int i = x + fillSize / 2; i &lt; x + fillSize; ++i) &#123; for (int j = y; j &lt; y + fillSize / 2; ++j) &#123; *(array + i * arraySize + j) = *(array + (i - fillSize / 2) * arraySize + (j + fillSize / 2)); &#125; &#125; for (int i = x + fillSize / 2; i &lt; x + fillSize; ++i) &#123; for (int j = y + fillSize / 2; j &lt; y + fillSize; ++j) &#123; *(array + i * arraySize + j) = *(array + (i - fillSize / 2) * arraySize + (j - fillSize / 2)); &#125; &#125;&#125;int main() &#123; int m; scanf(\"%d\", &amp;m); int competitorCount = pow(2, m); int arrangeArray[competitorCount][competitorCount]; int *arrangeArrayP = arrangeArray[0]; for (int k = 0; k &lt; competitorCount; ++k) &#123; arrangeArray[0][k] = k + 1; &#125; fillArray(0, 0, competitorCount, competitorCount, arrangeArrayP); for (int a = 0; a &lt; competitorCount; ++a) &#123; for (int b = 0; b &lt; competitorCount; ++b) &#123; printf(\"%d \", arrangeArray[a][b]); &#125; printf(\"\\n\"); &#125; return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"算法设计实验3-递归与分治-1116","slug":"Algorithm-Learning-Homework-201116","date":"2020-11-16T10:15:02.000Z","updated":"2020-11-17T05:25:06.000Z","comments":true,"path":"2020/11/16/Algorithm-Learning-Homework-201116/","link":"","permalink":"https://xdh129.github.io/2020/11/16/Algorithm-Learning-Homework-201116/","excerpt":"","text":"Fibonacci数列 无穷数列1，1，2，3，5，8，13，21，34，55，……，称为Fibonacci数列。它可以被递归地定义为: 第n个Fibonacci数可递归地计算如下： int fibonacci(int n) { if (n &lt;= 1) { return 1; } return fibonacci(n - 1) + fibonacci(n - 2);} 1) 编写完整的主函数，分别记录利用上述递归函数求第47, 48, 49, 50, 51,52个Fibonacci数所花费的时间。 程序代码:12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;time.h&gt;long long fibonacci(int n) &#123; if (n &lt;= 1) &#123; return 1; &#125; return fibonacci(n - 1) + fibonacci(n - 2);&#125;int main() &#123; time_t startTime, endTime; startTime = clock(); for (int k = 47; k &lt;= 52; ++k) &#123; printf(\"%lld \", fibonacci(k)); &#125; endTime = clock(); printf(\"\\n计算总耗时为 %.fms\", difftime(endTime, startTime)); return 0;&#125; 运行截图: 运行截图 2) 将递归函数改为尾递归，或者是递推函数，求第47,48,49,50,51,52个Fibonacci数所花费的时间，观察效率是否得到提高。 程序代码:12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;time.h&gt;long long fibonacci(int n) &#123; long long a = 1, b = 1, c = 2; for (int k = 1; k &lt; n; ++k) &#123; c = a + b; a = b; b = c; &#125; return c;&#125;int main() &#123; time_t startTime, endTime; startTime = clock(); for (int k = 47; k &lt;= 52; ++k) &#123; printf(\"%lld \", fibonacci(k)); &#125; endTime = clock(); printf(\"\\n计算总耗时为 %.fms\", difftime(endTime, startTime)); return 0;&#125; 运行截图: 运行截图 角谷定理 角谷定理。输入一个自然数,若为偶数,则把它除以2,若为奇数,则把它乘以3加1。经过如此有限次运算后,总可以得到自然数值1。求经过多少次可得到自然数1。 程序代码:1234567891011121314151617#include &lt;stdio.h&gt;int main() &#123; int n, count = 0; scanf(\"%d\", &amp;n); while (n != 1) &#123; if (n % 2 == 0) &#123; n /= 2; &#125; else &#123; n = n * 3 + 1; &#125; ++count; &#125; printf(\"%d\\n\", count); return 0;&#125; 运行截图: 运行截图 n级台阶计算走法 有n级台阶，可以一步上一个台阶，也可以一步上两个台阶，编写程序，计算共有多少种不同的走法。 程序代码:1234567891011121314151617181920#include &lt;stdio.h&gt;long long fibonacci(int n) &#123; long long a = 1, b = 1, c = 2; for (int k = 1; k &lt; n; ++k) &#123; c = a + b; a = b; b = c; &#125; return c;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); printf(\"上%d级台阶共有%lld种走法\\n\", n, fibonacci(n)); return 0;&#125; 运行截图: 运行截图 半数集问题4.半数集问题。问题描述：给定一个自然数n，由n开始可以依次产生半数集set(n)中的数如下：(1)n∈set(n);(2) 在n的左边加上一个自然数，但该自然数不能超过最近添加的数的一半；(3) 按此规则进行处理，直到不能再添加自然数为止。例如，set(6)={6,16,26,126,36,136}，半数集set(6)中有6个元素。输入：整数n(0&lt;n&lt;1000)输出：半数集set(n)中的元素个数。请设计递归函数，求出set(n)的个数，并分析算法时间复杂度，对算法进行改进，用程序验证递归算法，以及改进之后的算法。 递归算法: 程序代码:12345678910111213141516171819#include &lt;stdio.h&gt;int HalfSet(int n) &#123; int temp = 1; if (n &gt; 1) &#123; for (int k = 1; k &lt;= n / 2; ++k) &#123; temp += HalfSet(k); &#125; &#125; return temp;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", HalfSet(n)); return 0;&#125; 运行截图: 运行截图 改进之后的算法: 程序代码:1234567891011121314151617181920212223#include &lt;stdio.h&gt;int halfSet[1000];int HalfSet(int n) &#123; int temp = 1; if (halfSet[n]) &#123; return halfSet[n]; &#125; for (int k = 1; k &lt;= n / 2; ++k) &#123; temp += HalfSet(k); &#125; return temp;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", HalfSet(n)); return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"PTA拼题网作业-算法_枚举-1111","slug":"Algorithm-Learning-OnLine-Homework-201111","date":"2020-11-11T12:31:41.000Z","updated":"2020-11-12T05:25:06.000Z","comments":true,"path":"2020/11/11/Algorithm-Learning-OnLine-Homework-201111/","link":"","permalink":"https://xdh129.github.io/2020/11/11/Algorithm-Learning-OnLine-Homework-201111/","excerpt":"","text":"穷举问题-搬砖 某工地需要搬运砖块，已知男人一人搬3块，女人一人搬2块，小孩两人搬1块。如果想用n人正好搬n块砖，问有多少种搬法？ 输入格式:输入在一行中给出一个正整数n。 输出格式: 输出在每一行显示一种方案，按照”men = cnt_m, women = cnt_w, child = cnt_c”的格式，输出男人的数量cnt_m，女人的数量cnt_w，小孩的数量cnt_c。请注意，等号的两侧各有一个空格，逗号的后面也有一个空格。 如果找不到符合条件的方案，则输出”None”输入样例: 45 输出样例: men = 0, women = 15, child = 30men = 3, women = 10, child = 32men = 6, women = 5, child = 34men = 9, women = 0, child = 36 程序代码:12345678910111213141516171819202122#include &lt;stdio.h&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); int foundFlag = 0; for (int i = 0; i &lt; n / 3; ++i) &#123; for (int j = n / 2; j &gt;= 0; --j) &#123; for (int k = 0; k &lt; 2 * n; k += 2) &#123; if (i + j + k == n &amp;&amp; i * 3 + j * 2 + k / 2 == n) &#123; printf(\"mem = %d, women = %d, child = %d\\n\", i, j, k); foundFlag = 1; &#125; &#125; &#125; &#125; if (!foundFlag) &#123; printf(\"None\\n\"); &#125; return 0;&#125; 运行截图: 运行截图 百鸡问题扩展-N鸡问题 N元钱买N只鸡，公鸡每只5元，母鸡每只3元，小鸡1元3只，N元钱必须刚好买N只鸡，而且鸡必须整只买，不能劈开买。有几种买法呢？这就是N鸡问题。输入格式: 在一行中输入一个正整数N。（N&lt;500）输出格式: 在一行中输出两个整数c s，中间用一个空格隔开，表示N元钱买N只鸡共有 c 种买法，且所有买法的公鸡数量之和是 s。如果无解，则 s 为 -1.输入样例1: 100 输出样例1: 4 24 输入样例2: 1 输出样例2: 0 -1 程序代码:123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main() &#123; int n, c = 0, s = 0; scanf(\"%d\", &amp;n); int foundFlag = 0; for (int i = 0; i &lt;= n / 5; ++i) &#123; for (int j = 0; j &lt;= n / 3; ++j) &#123; int k = n - i - j; if (5 * i + 3 * j + k / 3 == n &amp;&amp; k % 3 == 0) &#123; ++c; s += i; foundFlag = 1; &#125; &#125; &#125; if (foundFlag) &#123; printf(\"%d %d\\n\", c, s); &#125; else &#123; printf(\"%d -1\\n\", c); &#125; return 0;&#125; 运行截图: 运行截图 输出全排列 输入整数n（3&lt;=n&lt;=7）,编写程序输出1,2,…,n整数的全排列，按字典序输出。输入格式: 一行输入正整数n。输出格式: 按字典序输出1到n的全排列。每种排列占一行，数字间无空格。输入样例: 在这里给出一组输入。例如： 3 输出样例: 在这里给出相应的输出。例如： 123132213231312321 程序代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;bool customSortAlgo(int a, int b) &#123; return a &lt; b;&#125;bool checkArrayOrder(int *array, int arraySize) &#123; if (arraySize &lt; 2) &#123; return false; &#125; int i = 0, j = 1; while (j != arraySize - 1 &amp;&amp; (array[i] &gt;= array[j])) &#123; ++i; ++j; &#125; if ((array[i] &gt;= array[j]) &amp;&amp; j == arraySize - 1) &#123; return false; &#125; return true;&#125;int main() &#123; int arraySize; std::cin &gt;&gt; arraySize; int numArray[7] = &#123;1, 2, 3, 4, 5, 6, 7&#125;; for (int k = 0; k &lt; arraySize; ++k) &#123; std::cout &lt;&lt; numArray[k]; &#125; std::cout &lt;&lt; std::endl; while (checkArrayOrder(numArray, arraySize)) &#123; int k = arraySize - 1; while (k != 0 &amp;&amp; numArray[k] &lt;= numArray[k - 1]) &#123; while (k - 1 != 0 &amp;&amp; numArray[k] &lt;= numArray[k - 1]) &#123; --k; &#125; if (numArray[k - 1] &lt; numArray[k]) &#123; break; &#125; else &#123; --k; &#125; &#125; if (numArray[k - 1] &lt; numArray[k]) &#123; int a = numArray[k - 1]; int aPos = k - 1; k = arraySize - 1; while (k != 0 &amp;&amp; a &gt;= numArray[k]) &#123; --k; &#125; if (a &lt; numArray[k]) &#123; int temp = numArray[k]; numArray[k] = numArray[aPos]; numArray[aPos] = temp; &#125; std::sort(numArray + aPos + 1, numArray + arraySize, customSortAlgo); &#125; for (int k = 0; k &lt; arraySize; ++k) &#123; std::cout &lt;&lt; numArray[k]; &#125; std::cout &lt;&lt; std::endl; &#125; return 0;&#125; 运行截图: 运行截图 梅森数4.形如2​n​​−1的素数称为梅森数（Mersenne Number）。例如2​2​​−1=3、2​3​​−1=7都是梅森数。1722年，双目失明的瑞士数学大师欧拉证明了2​31​​−1=2147483647是一个素数，堪称当时世界上“已知最大素数”的一个记录。 本题要求编写程序，对任一正整数n（n&lt;20），输出所有不超过2​n​​−1的梅森数。输入格式： 输入在一行中给出正整数n（n&lt;20）。输出格式： 按从小到大的顺序输出所有不超过2​n​​−1的梅森数，每行一个。如果完全没有，则输出“None”。输入样例： 6 输出样例： 3731 程序代码:123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); int foundFlag = 0; for (int k = 2; k &lt;= n; ++k) &#123; int temp = pow(2, k) - 1; int x; for (x = 2; x &lt;= sqrt(temp); ++x) &#123; if (temp % x == 0) &#123; break; &#125; &#125; if (x &gt; sqrt(temp)) &#123; printf(\"%d\\n\", temp); foundFlag = 1; &#125; &#125; if (!foundFlag) &#123; printf(\"None\"); &#125; return 0;&#125; 运行截图: 运行截图 换硬币 将一笔零钱换成5分、2分和1分的硬币，要求每种硬币至少有一枚，有几种不同的换法？ 输入格式: 输入在一行中给出待换的零钱数额x∈(8,100)。 输出格式: 要求按5分、2分和1分硬币的数量依次从大到小的顺序，输出各种换法。每行输出一种换法，格式为：“fen5:5分硬币数量, fen2:2分硬币数量, fen1:1分硬币数量, total:硬币总数量”。最后一行输出“count = 换法个数”。 输入样例: 13 输出样例: fen5:2, fen2:1, fen1:1, total:4fen5:1, fen2:3, fen1:2, total:6fen5:1, fen2:2, fen1:4, total:7fen5:1, fen2:1, fen1:6, total:8count = 4 程序代码:1234567891011121314#include &lt;stdio.h&gt;int main() &#123; int n, count = 0; scanf(\"%d\", &amp;n); for (int i = (n - 3) / 5; i &gt;= 1; --i) &#123; for (int j = (n - 5 * i - 1) / 2; j &gt;= 1; --j) &#123; ++count; printf(\"fen5:%d, fen2:%d, fen1:%d, total:%d\\n\", i, j, n - 5 * i - 2 * j, i + j + n - 5 * i - 2 * j); &#125; &#125; printf(\"count = %d\", count); return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"算法设计实验2-枚举与递推-1111","slug":"Algorithm-Learning-Homework-201111","date":"2020-11-11T12:15:02.000Z","updated":"2020-11-12T05:25:06.000Z","comments":true,"path":"2020/11/11/Algorithm-Learning-Homework-201111/","link":"","permalink":"https://xdh129.github.io/2020/11/11/Algorithm-Learning-Homework-201111/","excerpt":"","text":"输出所有可能的五位数 由0到4五个数字，组成5位数，每个数字用一次，但十位和百位不能为3（当然万位不能为0），输出所有可能的五位数。 程序代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;algorithm&gt;bool customSortAlgo(int a, int b) &#123; return a &lt; b;&#125;bool checkArrayOrder(int *array, int arraySize) &#123; if (arraySize &lt; 2) &#123; return false; &#125; int i = 0, j = 1; while (j != arraySize - 1 &amp;&amp; (*(array + i) &gt;= *(array + j))) &#123; ++i; ++j; &#125; if ((*(array + i) &gt;= *(array + j)) &amp;&amp; j == arraySize - 1) &#123; return false; &#125; return true;&#125;void customShowArray(int *array, int arraySize) &#123; if (*(array) &amp;&amp; *(array + 2) &amp;&amp; *(array + 3)) &#123; for (int k = 0; k &lt; arraySize; ++k) &#123; std::cout &lt;&lt; *(array + k); &#125; std::cout &lt;&lt; std::endl; &#125;&#125;int main() &#123; int arraySize; arraySize = 5; //std::cin &gt;&gt; arraySize; int numArray[5] = &#123;0, 1, 2, 3, 4&#125;; while (checkArrayOrder(numArray, arraySize)) &#123; int k = arraySize - 1; while (k != 0 &amp;&amp; numArray[k] &lt;= numArray[k - 1]) &#123; while (k - 1 != 0 &amp;&amp; numArray[k] &lt;= numArray[k - 1]) &#123; --k; &#125; if (numArray[k - 1] &lt; numArray[k]) &#123; break; &#125; else &#123; --k; &#125; &#125; if (numArray[k - 1] &lt; numArray[k]) &#123; int a = numArray[k - 1]; int aPos = k - 1; k = arraySize - 1; while (k != 0 &amp;&amp; a &gt;= numArray[k]) &#123; --k; &#125; if (a &lt; numArray[k]) &#123; int temp = numArray[k]; numArray[k] = numArray[aPos]; numArray[aPos] = temp; &#125; std::sort(numArray + aPos + 1, numArray + arraySize, customSortAlgo); &#125; customShowArray(numArray, arraySize); &#125; return 0;&#125; 运行截图: 运行截图 最大子段和问题 最大子段和问题给定由n个整数组成的序列，求序列中子段的最大和，若所有整数均为负整数时定义最大子段和为0。例如, 当（a1,a2,a3,a4 ,a5,a6) = （-2,11,-4,13,-5,-2）时，最大子段和为: a2+a3+a4=20输入格式:第一行输入整数个数n（1≤n≤10000），再依次输入n个整数。输出格式:输出第一行为最大子段和，第二行为子段第一个数和最后一个数在整个序列中的位序。输入样例1:5 -2 11 -4 13 -5 -2输出样例1:202 4 程序代码:12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main() &#123; int arraySize; scanf(\"%d\", &amp;arraySize); int intArray[arraySize]; for (int k = 0; k &lt; arraySize; ++k) &#123; scanf(\"%d\", &amp;intArray[k]); &#125; int sumBeginPos, sumEndPos, currentMaxSum = 0; for (int i = 0; i &lt; arraySize; ++i) &#123; int nextSum = intArray[i]; for (int j = i + 1; j &lt; arraySize; ++j) &#123; nextSum = nextSum + intArray[j]; if (nextSum &gt; currentMaxSum) &#123; currentMaxSum = nextSum; sumBeginPos = i + 1; sumEndPos = j + 1; &#125; &#125; &#125; printf(\"%d\\n\", currentMaxSum); printf(\"%d %d\\n\", sumBeginPos, sumEndPos); return 0;&#125; 运行截图: 运行截图 列出所有可能的比赛名单 有两队选手每队5人进行一对一的比赛，甲队为A、B、C、D、E，乙队为J、K、L、M、N，经过抽签决定比赛对手名单。规定A不和J比赛， M不和D及E比赛。列出所有可能的比赛名单。 程序代码:123456789101112#include &lt;stdio.h&gt;int main() &#123; for (int i = 65; i &lt; 70; ++i) &#123; for (int j = 74; j &lt; 79; ++j) &#123; if (!((i == 65 &amp;&amp; j == 74) || (j == 77 &amp;&amp; (i == 68 || i == 69)))) &#123; printf(\"%c versus %c\\n\", i, j); &#125; &#125; &#125; return 0;&#125; 运行截图: 运行截图 推算荒岛上最初有多少金币4.有5个海盗，相约进行一次帆船比赛。比赛中天气发生突变，他们被冲散了，恰巧，他们都先后经过途中的一个无名的荒岛，并且每个人都信心满满，觉得自己实第一个经过该岛的人。第一个人在沙滩上发现了一堆金币。他把金币分成5等份。发现刚好少一个金币。他就从自己口袋拿出一个金币补充进去，然后把属于自己的那份拿走。第二个到达的人也看到了金币，他也和第一个人一样，把所有金币5等分，发现刚好缺少一个金币，于是自己补进去一个，拿走了属于自己的那份。第三，第四，第五人的情况一模一样。等他们到了目的地，都说自己的情况，才恍然大悟，一起去荒岛找金币，然而再也没有找到荒岛。他们都惋惜地说：岛上还有一千多枚金币呢！请你根据这些信息，推算荒岛上最初有多少金币？ 程序代码:12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main() &#123; int coinCount = 1000; int foundFlag = 0; while (!foundFlag) &#123; ++coinCount; int temp = coinCount; for (int k = 0; k &lt; 5; ++k) &#123; if (!((int) ((temp + 1) * 0.8) % 4) &amp;&amp; temp % 5 == 4) &#123; if (k == 4) &#123; foundFlag = 1; printf(\"荒岛上最初有%d枚金币\\n\", coinCount); break; &#125; ++temp; temp *= 0.8; &#125; &#125; &#125; return 0;&#125; 运行截图: 运行截图 冰雹粒子在冰雹云中翻滚增长5.任意给定一个正整数N，如果是偶数，执行：N/2；如果是奇数，执行：N*3+1。生成的新的数字再执行同样的动作，循环往复，通过观察发现，这个数字会一会儿上升到很高，一会儿又降落下来。就这样起起落落的，但最终必会落到“1”这有点像小冰雹粒子在冰雹云中翻滚增长的样子。比如N=9：9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1可以看到，N=9的时候，这个“小冰雹”最高冲到了52这个高度。输入格式：一个正整数N（N&lt;1000000）输出格式：一个正整数，表示不大于N的数字，经过冰雹数变换过程中，最高冲到了多少。例如，输入： 10 程序应该输出： 52 再例如，输入： 100 程序应该输出： 9232 程序代码:1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main() &#123; int n, max = 0; scanf(\"%d\", &amp;n); for (int k = 1; k &lt;= n; ++k) &#123; int temp = k; while (temp != 1) &#123; if (temp % 2 == 0) &#123; temp /= 2; &#125; else &#123; temp = temp * 3 + 1; &#125; if (temp &gt; max) &#123; max = temp; &#125; &#125; &#125; printf(\"%d\\n\", max); return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"PTA拼题网作业-算法_绪论-1109","slug":"Algorithm-Learning-OnLine-Homework-201109","date":"2020-11-09T10:53:47.000Z","updated":"2020-11-10T12:40:53.000Z","comments":true,"path":"2020/11/09/Algorithm-Learning-OnLine-Homework-201109/","link":"","permalink":"https://xdh129.github.io/2020/11/09/Algorithm-Learning-OnLine-Homework-201109/","excerpt":"","text":"办事大厅排队 在郑州大学综合办事大厅，每天陆陆续续有很多人来排队办事。现在你能否写程序帮助老师时刻了解当前办理业务的情况。 请同学们学习C++ STL中 list相关内容后，编程实践。输入格式: 第一行一个数字N，表示排队信息或者查询信息条目的数量。 以下N行，每行的内容有以下3种情况 (1) in name 表示名字为name的人员新来到办事大厅，排在队伍的最后。（in和name间存在一个空格，name是名字对应字符串，长度不超过10）。 (2) out 表示当前排在最前面的人已经办理完业务，离开了。 (3) q 表示一次查询，请输出当前正在办理业务的人，也就是队伍的第1个人。如果当前无人办理业务，则输出“NULL”，不包括引号。输出格式: 请根据以上信息，每次遇到查询时，对应一行输出。如果这时队伍有人，则输出第一个人的姓名，否则输出NULL。输入样例: 5in Aoutqin Bq 输出样例: 在这里给出相应的输出。例如： NULLB 程序代码:123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;list&gt;int main() &#123; int querySize; std::cin &gt;&gt; querySize; std::list&lt;std::string&gt; listQueue; std::string nextArg; for (int k = 0; k &lt; querySize; ++k) &#123; std::cin &gt;&gt; nextArg; if (nextArg == \"in\") &#123; std::cin &gt;&gt; nextArg; listQueue.emplace_back(nextArg); &#125; if (nextArg == \"out\") &#123; listQueue.pop_front(); &#125; if (nextArg == \"q\") &#123; if (!listQueue.empty()) &#123; std::cout &lt;&lt; listQueue.front(); &#125; else &#123; std::cout &lt;&lt; \"NULL\"; &#125; std::cout &lt;&lt; std::endl; &#125; &#125; return 0;&#125; 运行截图: 运行截图 利用STL比较数据大小并排序 本题目要求读入n个整数（输入数字个数根据输入时随机确定，以输入一个非数字的值作为输入结束标志），利用STL比较数据大小并排序（由小到大升序），然后输出排序后的数据。 输入格式: 输入在一行中依次输入整数值，每个数字之间用空格分隔，输入数字个数根据输入时随机确定，以输入一个非数字的值作为输入结束标志。 输出格式: 先输出一段提示“从标准设备读入数据，直到输入是非整型数据为止”，在输入一组数字后，输出排序后的数字，在一行中由小到大依次输出所有值，数字之间用空格分隔。输入样例: 10 3 -2 8 20 -9 e 输出样例: 从标准设备读入数据，直到输入是非整型数据为止 -9 -2 3 8 10 20 程序代码:12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;bool customSortAlgo(int a, int b) &#123; return a &lt; b;&#125;int main() &#123; std::vector&lt;int&gt; intVector; int nextInt; std::cout &lt;&lt; \"从标准设备读入数据，直到输入是非整型数据为止\" &lt;&lt; std::endl; while (std::cin &gt;&gt; nextInt) &#123; intVector.emplace_back(nextInt); &#125; intVector.shrink_to_fit(); std::sort(intVector.begin(), intVector.end(), customSortAlgo); for (std::vector&lt;int&gt;::iterator iter = intVector.begin(); iter != intVector.end(); ++iter) &#123; std::cout &lt;&lt; \" \" &lt;&lt; *iter; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 运行截图: 运行截图 跳一跳 微信小程序中的跳一跳相信大家都玩过。emmm？？？只学习不玩游戏？那就吃亏了…好好读题理解吧。 简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。 如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8…）。 现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。 输入格式: 输入包含多个数字，用空格分隔，每个数字都是1，2，0之一， 1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。 对于所有评测用例，输入的数字不超过30个 输出格式: 输出一个整数，为本局游戏的得分（在本题的规则下）。输入样例: 1 1 2 2 2 1 1 2 2 0 输出样例: 22 程序代码:123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int main() &#123; int nextInt, loopFlag = 1, jumpCombo = 0, totalScore = 0; while (loopFlag) &#123; scanf(\"%d\", &amp;nextInt); switch (nextInt) &#123; case 1: &#123; jumpCombo = 0; ++totalScore; break; &#125; case 2: &#123; if (jumpCombo != 0) &#123; ++jumpCombo; totalScore += jumpCombo * 2; &#125; else &#123; jumpCombo = 1; totalScore += 2; &#125; break; &#125; case 0: &#123; loopFlag = 0; break; &#125; &#125; &#125; printf(\"%d\\n\", totalScore); return 0;&#125; 运行截图: 运行截图 排序4.给定N个（长整型范围内的）整数，要求输出从小到大排序后的结果。 本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下：数据1：只有1个元素；数据2：11个不相同的整数，测试基本正确性；数据3：103个随机整数；数据4：104个随机整数；数据5：105个随机整数；数据6：105个顺序整数；数据7：105个逆序整数；数据8：105个基本有序的整数；数据9：105个随机正整数，每个数字不超过1000。 输入格式: 输入第一行给出正整数N（≤10​5​​），随后一行给出N个（长整型范围内的）整数，其间以空格分隔。 输出格式: 在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。 输入样例: 114 981 10 -17 0 -20 29 50 8 43 -5 输出样例: -20 -17 -5 0 4 8 10 29 43 50 981 程序代码:123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;bool customSortAlgo(int a, int b) &#123; return a &lt; b;&#125;int main() &#123; int arraySize; std::cin &gt;&gt; arraySize; int intArray[100000]; for (int k = 0; k &lt; arraySize; ++k) &#123; std::cin &gt;&gt; intArray[k]; &#125; std::sort(intArray, intArray + arraySize, customSortAlgo); for (int k = 0; k &lt; arraySize - 1; ++k) &#123; std::cout &lt;&lt; intArray[k] &lt;&lt; \" \"; &#125; std::cout &lt;&lt; intArray[arraySize - 1]; return 0;&#125; 运行截图: 运行截图 求前缀表达式的值 算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3*(7-4)+8/4的前缀表达式是：+ + 2 * 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。 输入格式: 输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。 输出格式: 输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。 输入样例: 2 * 3 - 7 4 / 8 4 输出样例: 13.0 程序代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;stack&gt;int main() &#123; std::string exps[100]; bool flag = 0; int expSize = 0; std::stack&lt;double&gt; calcStack; while (std::cin &gt;&gt; exps[expSize++]) &#123; &#125; expSize -= 1; for (int k = expSize - 1; k &gt;= 0; k--) &#123; if (exps[k].length() == 1 &amp;&amp; (exps[k][0] == '+' || exps[k][0] == '-' || exps[k][0] == '*' || exps[k][0] == '/')) &#123; if (calcStack.size() &lt; 2) &#123; flag = 1; break; &#125; double a = calcStack.top(); calcStack.pop(); double b = calcStack.top(); calcStack.pop(); switch (exps[k][0]) &#123; case '+': &#123; calcStack.push(a + b); break; &#125; case '-': &#123; calcStack.push(a - b); break; &#125; case '*': &#123; calcStack.push(a * b); break; &#125; case '/': &#123; if(b==0)&#123; break; &#125; calcStack.push(a / b); break; &#125; &#125; &#125; else &#123; double x = atof(exps[k].c_str()); calcStack.push(x); &#125; &#125; if (calcStack.size() != 1) &#123; flag = 1; &#125; if (flag) &#123; printf(\"ERROR\"); &#125; else &#123; printf(\"%.1f\", calcStack.top()); &#125; return 0;&#125; 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"算法设计实验1-算法设计基础-1109","slug":"Algorithm-Learning-Homework-201109","date":"2020-11-09T10:33:47.000Z","updated":"2020-11-10T12:40:53.000Z","comments":true,"path":"2020/11/09/Algorithm-Learning-Homework-201109/","link":"","permalink":"https://xdh129.github.io/2020/11/09/Algorithm-Learning-Homework-201109/","excerpt":"","text":"求两个整数的最大公约数1.分别用穷举法和欧几里德算法实现求两个整数的最大公约数，并比较算法的效率。 程序代码:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;time.h&gt;int getGCDEuclid(int a, int b) &#123; int temp; while (b) &#123; temp = b; b = a % b; a = temp; &#125; return a;&#125;int getGCDExhaustive(int a, int b) &#123; int temp = a &gt; b ? a : b; while (a % temp || b % temp) &#123; --temp; &#125; return temp;&#125;int main() &#123; time_t startTime, endTime; startTime = clock(); for (int k = 0; k &lt; 1000000; ++k) &#123; getGCDEuclid(21, 10001203); &#125; endTime = clock(); printf(\"使用欧几里得法求两个整数的最大公约数1000000次耗时为 %fms\\n\", difftime(endTime, startTime)); startTime = clock(); for (int k = 0; k &lt; 100; ++k) &#123; getGCDExhaustive(21, 10001203); &#125; endTime = clock(); printf(\"使用穷举法求两个整数的最大公约数100次耗时为 %fms\\n\", difftime(endTime, startTime)); return 0;&#125; 运行截图: 运行截图 排序算法效率比较2.编程实现以下几种不同的排序算法（以升序为例）：冒泡排序、选择排序、希尔排序、快速排序，比较不同的排序过程的运行时间。具体要求：（1）为了消除数据之间差异导致排序效果的影响，使用相同的数组进行排序，方法为：首先创建一个数组，数组长度至少为100000，数组元素取值范围在[0, 100000]。 之间的随机正整数，并将这个数组复制4份，分别用不同的排序算法进行排序。（2）记录不同排序算法的运行时间。（3）对完全逆序的情况进行测试，将待排序数组赋值为逆序，即与最终排序要求完全相反。 程序代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;time.h&gt;void BubbleSort(int arraySize, int *arrayP) &#123; int isOrdered = 1; for (int i = 0; i &lt; arraySize - 1; ++i) &#123; for (int j = 0; j &lt; arraySize - i - 1; ++j) &#123; if (*(arrayP + j) &gt; *(arrayP + j + 1)) &#123; int temp = *(arrayP + j); *(arrayP + j) = *(arrayP + j + 1); *(arrayP + j + 1) = temp; isOrdered = 0; &#125; &#125; if (isOrdered) &#123; return; &#125; &#125;&#125;void SelectionSort(int arraySize, int *arrayP) &#123; for (int i = 0; i &lt; arraySize - 1; ++i) &#123; for (int j = i + 1; j &lt; arraySize; ++j) &#123; if (*(arrayP + i) &gt; *(arrayP + j)) &#123; int temp = *(arrayP + i); *(arrayP + i) = *(arrayP + j); *(arrayP + j) = temp; &#125; &#125; &#125;&#125;void ShellSort(int arraySize, int *arrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; int temp = *(arrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &gt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; &#125; &#125; &#125;&#125;void InvertedShellSort(int arraySize, int *arrayP) &#123; for (int gap = arraySize / 2; gap &gt; 0; gap /= 2) &#123; for (int i = 0; i &lt; gap; ++i) &#123; for (int j = i + gap; j &lt; arraySize; j += gap) &#123; int temp = *(arrayP + j); int k = j - gap; while (k &gt;= 0 &amp;&amp; *(arrayP + k) &lt; temp) &#123; *(arrayP + k + gap) = *(arrayP + k); k -= gap; &#125; *(arrayP + k + gap) = temp; &#125; &#125; &#125;&#125;void QuickSort(int start, int end, int *arrayP) &#123; int a = start; int b = end; int temp = *(arrayP + start); if (start &gt;= end) &#123; return; &#125; while (start &lt; end) &#123; while (start &lt; end &amp;&amp; temp &lt;= *(arrayP + end)) &#123; --end; &#125; if (temp &gt; *(arrayP + end)) &#123; *(arrayP + start) = *(arrayP + end); ++start; &#125; while (start &lt; end &amp;&amp; temp &gt;= *(arrayP + start)) &#123; ++start; &#125; if (temp &lt; arrayP[start]) &#123; *(arrayP + end) = *(arrayP + start); --end; &#125; &#125; *(arrayP + start) = temp; QuickSort(a, start - 1, arrayP); QuickSort(start + 1, b, arrayP);&#125;int main() &#123; time_t startTime, endTime; int randomIntArrayBubbleSort[100000], randomIntArraySelectionSort[100000], randomIntArrayShellSort[100000], randomIntArrayQuickSort[100000]; for (int k = 0; k &lt; 100000; ++k) &#123; randomIntArrayBubbleSort[k] = ((rand() &lt;&lt; 2) ^ rand()) % 100000; &#125; memcpy(randomIntArraySelectionSort, randomIntArrayBubbleSort, sizeof(randomIntArrayBubbleSort)); memcpy(randomIntArrayShellSort, randomIntArrayBubbleSort, sizeof(randomIntArrayBubbleSort)); memcpy(randomIntArrayQuickSort, randomIntArrayBubbleSort, sizeof(randomIntArrayBubbleSort)); printf(\"大小为100000的随机数组排序\\n\"); startTime = clock(); BubbleSort(100000, randomIntArrayBubbleSort); endTime = clock(); printf(\"冒泡排序用时: %.1fms\\n\", difftime(endTime, startTime)); startTime = clock(); SelectionSort(100000, randomIntArraySelectionSort); endTime = clock(); printf(\"选择排序用时: %.1fms\\n\", difftime(endTime, startTime)); startTime = clock(); ShellSort(100000, randomIntArrayShellSort); endTime = clock(); printf(\"希尔排序用时: %.1fms\\n\", difftime(endTime, startTime)); startTime = clock(); QuickSort(0, 99999, randomIntArrayQuickSort); endTime = clock(); printf(\"快速排序用时: %.1fms\\n\", difftime(endTime, startTime)); InvertedShellSort(100000, randomIntArrayBubbleSort); memcpy(randomIntArraySelectionSort, randomIntArrayBubbleSort, sizeof(randomIntArrayBubbleSort)); memcpy(randomIntArrayShellSort, randomIntArrayBubbleSort, sizeof(randomIntArrayBubbleSort)); memcpy(randomIntArrayQuickSort, randomIntArrayBubbleSort, sizeof(randomIntArrayBubbleSort)); printf(\"大小为100000的逆序数组排序\\n\"); startTime = clock(); BubbleSort(100000, randomIntArrayBubbleSort); endTime = clock(); printf(\"冒泡排序用时: %.1fms\\n\", difftime(endTime, startTime)); startTime = clock(); SelectionSort(100000, randomIntArraySelectionSort); endTime = clock(); printf(\"选择排序用时: %.1fms\\n\", difftime(endTime, startTime)); startTime = clock(); ShellSort(100000, randomIntArrayShellSort); endTime = clock(); printf(\"希尔排序用时: %.1fms\\n\", difftime(endTime, startTime)); startTime = clock(); QuickSort(0, 99999, randomIntArrayQuickSort); endTime = clock(); printf(\"快速排序用时: %.1fms\\n\", difftime(endTime, startTime)); return 0;&#125; 为了避免堆栈溢出，通过配置CMakeList.txt手动修改了堆栈大小为16M: CMake配置截图 运行截图: 运行截图","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"软件工程作业-1020/1026","slug":"Software-Engineering-Homework-201020","date":"2020-10-20T11:23:47.000Z","updated":"2020-10-26T09:40:53.000Z","comments":true,"path":"2020/10/20/Software-Engineering-Homework-201020/","link":"","permalink":"https://xdh129.github.io/2020/10/20/Software-Engineering-Homework-201020/","excerpt":"","text":"MVC与MVP的区别MVC模式指Model-View-Controller(模型-视图-控制器)模式，MVP模式指Model-View-Presenter模式。 MVC: Model：数据处理层，可以直接和View进行交互View：布局，界面逻辑Controller：把特定的功能逻辑抽离出来，作为控制层，保证View层和Model层的功能单一性，便于维护 MVP: Model：数据处理层View：显示层Presenter：功能逻辑层 JSP内置对象session与HttpSession是同一个东西吗？它们的使用方法是一样的，并且存放在session对象中的数据都是保存在服务器端的","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"软件工程","slug":"软件工程","permalink":"https://xdh129.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"软件工程作业-1015","slug":"Software-Engineering-Homework-201015","date":"2020-10-15T11:02:12.000Z","updated":"2020-10-15T11:02:12.000Z","comments":true,"path":"2020/10/15/Software-Engineering-Homework-201015/","link":"","permalink":"https://xdh129.github.io/2020/10/15/Software-Engineering-Homework-201015/","excerpt":"","text":"什么是形式化方法?形式化方法是以严格的数学化和机械化方法为基础来规约、构建和验证计算系统，是改善和确保计算系统质量的重要方法，其模型、技术和工具已延生成为计算思维的重要载体。 在计算机科学和软件工程领域，形式化方法是基于数学的特种技术，适合于软件和硬件系统的描述、开发和验证。将形式化方法用于软件和硬件设计，是期望能够像其它工程学科一样，使用适当的数学分析以提高设计的可靠性和鲁棒性。但是，由于采用形式化方法的成本高意味着它们通常只用于开发注重安全性的高度整合的系统。形式化方法在古代就已有运用,而在现代逻辑中形式化方法又有了进一步的发展和完善。这种方法特别在数学、计算机科学、人工智能等领域得到广泛运用。它能精确地揭示各种逻辑规律,制定相应的逻辑规则,使各种理论体系更加严密。同时也能正确地训练思维、提高思维的抽象能力。","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"软件工程","slug":"软件工程","permalink":"https://xdh129.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"软件工程作业-1013","slug":"Software-Engineering-Homework-201013","date":"2020-10-14T05:30:26.000Z","updated":"2020-10-14T05:30:26.000Z","comments":true,"path":"2020/10/14/Software-Engineering-Homework-201013/","link":"","permalink":"https://xdh129.github.io/2020/10/14/Software-Engineering-Homework-201013/","excerpt":"","text":"1. 为什么软件开发的周期总是预估的2~3倍? Quora上有人提问：为什么软件开发的周期总是预估的2~3倍?这是开发者的错?还是管理的问题?技术粗糙，或者其他原因?或者这只是程序猿世界的自然法则? 总结: 软件开发的预估周期可能会和实际情况有偏差，开发的过程中会遇到各种各样的问题或者是需求的更改，从而延长软件开发的周期。 3. 什么是分而治之?以下为百度百科上的解答: 分而治之方法与软件设计的模块化方法非常相似。为了解决一个大的问题，可以： 1) 把它分成两个或多个更小的问题；2) 分别解决每个小问题；3) 把各小问题的解答组合起来，即可得到原问题的解答。 4. 什么是WBS?在实施计划的基础上，更进一步地将每项工作细化。经过细化的工作分别落实到某一个项目团队成员，落实到每一天，这种方法就叫做工作分解结构（WBS）法。WBS由最低级的工作任务组成，它是项目每一个阶段的时间表和路标。WBS可以将项目分解为一些更小和可操作的部分。WBS的每个阶段就好像是夹在起始日期和结束之内三明治，开始和结束日期的确定使项目的其他阶段可以按计划进行。每个阶段的起止日期明确也能保证项目经理可以预计何时整个项目能够圆满完成。 WBS的作用:WBS明确了完成项目所需进行的工作。也可使人产生紧迫感和责任感，为项目的如期完成而努力。WBS能防止项目范围的盲目扩大，当甲方打算向已存在的项目增加新内容时，WBS能避免这种事的发生，WBS提供了一种控制手段。","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"软件工程","slug":"软件工程","permalink":"https://xdh129.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"软件工程作业-0929","slug":"Software-Engineering-Homework-200929","date":"2020-09-30T12:26:48.000Z","updated":"2020-09-30T12:26:48.000Z","comments":true,"path":"2020/09/30/Software-Engineering-Homework-200929/","link":"","permalink":"https://xdh129.github.io/2020/09/30/Software-Engineering-Homework-200929/","excerpt":"","text":"1. 对软件工程课程的希望及个人目标通过软件工程这门课程，我希望能够学习到软件开发的工程设计方法与工程思想，因为它能够帮助我们更好地利用有限的时间，编写出结构更清晰，易于维护且尽可能高内聚低耦合的软件。 3. 软件工程是不是教会不怎么会写程序的人开发软件? “Software Engineering, of course, presents itself as another worthy cause, but that is eyewash: if you carefully read its literature and analyse what its devotees actually do, you will discover that Software Engineering has accepted as its charter ‘How to program if you cannot’.” 我认为软件工程本身是一种用来指导软件开发的理论思想，而它本身与开发软件所用到的实践性知识(比如语言/框架/API的使用)并不密切相关，但软件工程的工程设计思想确实能更好地指导大型软件的开发。 举一个例子，编写一个3D应用程序需要用到计算机图形学的知识，然而纯粹的计算机图形学并没有教授你如何实际开发一个3D应用程序，因为开发3D应用程序需要涉及到图形API的使用，但没有计算机图形学知识的铺垫，会很难理解开发中使用到的图形API是如何工作的。我觉得这个例子中计算机图形学与图形API(实际开发)的关系和软件工程思想与开发软件的关系比较类似。 GAMES101 Course 所以我不同意”软件工程就是教会不怎么会写程序的人开发软件”这一说法。4. the Manifesto for Software Craftsmanship地址: http://manifesto.softwarecraftsmanship.org the Manifesto for Software Craftsmanship 5. 有人负责，才有质量https://www.ituring.com.cn/article/9363如今软件中使用别的开源库/组件的情况非常普遍，因为对于大部分人来说，如果已经有了一个能动的而且经过多次完善加工过的轮子(成熟的框架)，就似乎没有必要再自己从无到有地再造一个轮子。而且我发现现在的软件开发已经不可避免地需要复用已有的框架/组件才能支撑接下来的开发，比如安卓需要基于各种Framework，iOS需要基于系统框架Foundation/UIKit/Core Graphics，因为现在的这些移动平台都已经经过多年的发展，形成了自己的一套体系，所以只有遵守这样的体系才能进行现代化的移动应用开发。 6. 软件工程方法论对我们的软件开发有多大用处?我认为软件工程方法论可以指导我们在有限的时间内开发出结构良好，易于维护且高内聚低耦合的软件。它包括技术和管理两方面的内容，技术方面包括一些软件结构的设计思想与设计模式，通过特定的开发方式能够创建出结构良好易于维护的软件。管理方面则是管理人员通过计划、组织和控制等方式，合理地推进软件的开发以及分配好所需的不同资源，让软件达到目的需求，最终得以成功开发。","categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"软件工程","slug":"软件工程","permalink":"https://xdh129.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"在Flutter应用中调用原生Java/C代码","slug":"Implementing-Native-Java-C-Code-in-a-Flutter-Application","date":"2020-09-20T07:55:41.000Z","updated":"2020-09-20T09:29:57.000Z","comments":true,"path":"2020/09/20/Implementing-Native-Java-C-Code-in-a-Flutter-Application/","link":"","permalink":"https://xdh129.github.io/2020/09/20/Implementing-Native-Java-C-Code-in-a-Flutter-Application/","excerpt":"","text":"Flutter Logo Flutter是谷歌的全新移动应用框架，它拥有的热重载以及跨平台的界面开发能力使得我们能在短时间内构建出界面美观的现代化移动应用。然而因为Flutter框架主要使用的是Dart语言，而一些系统SDK又是以原生Java代码编写的，这让调用成了一个问题。然而Flutter框架已经为我们准备好了解决方案，它允许我们在不同语言中互相调用方法。 Flutter允许开发者通过编写平台通道(Platform Channel)方法的方式来在Dart语言中调用以Kotlin/Java/Swift/Objetive-C编写的代码，来实现访问iOS和Android上的原生系统功能和系统SDK的目的。 以上是谷歌官方的介绍，所以在这里我将演示一下如何在使用Dart语言编写的Flutter应用中调用原生Java编写的代码。 1.在Flutter项目中再次打开其中的Java语言项目目录(Kotlin等其他语言同理) Flutter项目 Java语言项目目录 2.在Java语言项目目录的MainActivity.java文件中编写平台通道(Platform Channel)，以和Dart语言部分进行交互 其中CHANNEL变量为平台通道名称，需要和Dart语言中使用的平台通道名称一致 示例代码: 123456789101112131415161718192021222324public class MainActivity extends FlutterActivity &#123; private static final String CHANNEL = \"com.company.testplatformchannel\"; @Override public void configureFlutterEngine(@NonNull FlutterEngine flutterEngine) &#123; super.configureFlutterEngine(flutterEngine); new MethodChannel(flutterEngine.getDartExecutor().getBinaryMessenger(), CHANNEL) .setMethodCallHandler( (call, result) -&gt; &#123; // Note: this method is invoked on the main thread. if (call.method.equals(\"getSomgthingFromJava\")) &#123; if ((String) call.argument(\"inputText\") != null) &#123; result.success(getJavaText((String) call.argument(\"inputText\"), (int) call.argument(\"anotherArgument\"))); &#125; else &#123; result.error(\"UNAVAILABLE\", \"This Method is not available now.\", null); &#125; &#125; else &#123; result.notImplemented(); &#125; &#125; ); &#125;&#125; 3.在Dart语言部分调用平台通道(Platform Channel)，并尝试获取信息 123456789101112131415static const CHANNEL = const MethodChannel('com.company.testplatformchannel');Future&lt;void&gt; _getSomgthingFromJava(String inputText,int translateType) async &#123; String outputText; try &#123; String result = await CHANNEL.invokeMethod('getTranslateText',&#123;\"inputText\":inputText,\"anotherArgument\":anotherArgument&#125;); outputText = '$result'; &#125; on PlatformException catch (e) &#123; outputText = \"Failed to contact with that Java method: '$&#123;e.message&#125;'.\"; &#125; setState(() &#123; _outputText = outputText; &#125;);&#125; 更多关于如何在Flutter框架中使用平台通道的信息可以在这里找到:https://flutterchina.club/platform-channels/","categories":[{"name":"应用框架","slug":"应用框架","permalink":"https://xdh129.github.io/categories/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://xdh129.github.io/tags/Flutter/"},{"name":"iOS","slug":"iOS","permalink":"https://xdh129.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"https://xdh129.github.io/tags/Android/"},{"name":"跨平台","slug":"跨平台","permalink":"https://xdh129.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"name":"调用","slug":"调用","permalink":"https://xdh129.github.io/tags/%E8%B0%83%E7%94%A8/"},{"name":"Java","slug":"Java","permalink":"https://xdh129.github.io/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://xdh129.github.io/tags/Kotlin/"},{"name":"Dart","slug":"Dart","permalink":"https://xdh129.github.io/tags/Dart/"}]},{"title":"Hello World","slug":"hello-world-hexo","date":"2017-06-17T00:00:00.000Z","updated":"2017-06-17T00:00:00.000Z","comments":true,"path":"2017/06/17/hello-world-hexo/","link":"","permalink":"https://xdh129.github.io/2017/06/17/hello-world-hexo/","excerpt":"","text":"现已迁移至Hexo，一个轻量级的开源博客框架。From now on we’re running on Hexo, a lighter &amp; powerful open-source blog framework powered by Node.js.Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"此博客将暂停更新一段时间","slug":"stop-updating","date":"2014-01-04T05:56:21.000Z","updated":"2014-01-04T05:56:21.000Z","comments":true,"path":"2014/01/04/stop-updating/","link":"","permalink":"https://xdh129.github.io/2014/01/04/stop-updating/","excerpt":"","text":"博主决定以后将把自己的个人日记记在本机上，在这里博主也推荐一个记日记的软件，叫eDiary，对于记日记来说完全够用了。以后博主将会将大部分重心放在记本机日记上，不再更新此博客。","categories":[{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"停止","slug":"停止","permalink":"https://xdh129.github.io/tags/%E5%81%9C%E6%AD%A2/"},{"name":"日记","slug":"日记","permalink":"https://xdh129.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"更新","slug":"更新","permalink":"https://xdh129.github.io/tags/%E6%9B%B4%E6%96%B0/"},{"name":"软件","slug":"软件","permalink":"https://xdh129.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"使用带有离线下载功能的网盘转存Youtube视频教程","slug":"download-youtube-videos-to-domestic-online-disk","date":"2013-08-27T08:49:09.000Z","updated":"2013-08-27T08:49:09.000Z","comments":true,"path":"2013/08/27/download-youtube-videos-to-domestic-online-disk/","link":"","permalink":"https://xdh129.github.io/2013/08/27/download-youtube-videos-to-domestic-online-disk/","excerpt":"","text":"YouTube Logo 有时，我们看到喜欢的Youtube视频，需要把它转存至国内网盘，但却因为网络问题，无法快速上传/下载视频。没关系，这里有一个不需要本地下载Youtube视频即可将它存至国内网盘的办法。（此方法的主要目的不是下载Youtube视频，而是转存视频至国内网盘） 需要：一枚有离线下载功能的网盘的帐号 1.进入http://unrestrict.li/download，将想下载的u2b视频的地址粘贴进输入框中。然后点击“Unrestrict links!”。得到一排链接 步骤1图片 2.下面出现的这些链接是这个视频不同清晰度的下载地址，选择自己需要的那个（注意分辨率和文件后缀名），点击左边的“Download” 3.出现一个文件下载页面，我们按照提示输入验证码，如看不清，点击输入框右边的旋转图标，输入完后，点击下面的“Download” 步骤3图片 4.出现了真正的文件下载页面，不要直接点击，右键复制它的链接即可 步骤4图片 PS：这时还不能直接进入网盘，直接离线下载，因为直接使用此链接离线下载，网盘会提示“地址中含有非法字符”或“参数错误”(BUG) 5.百度搜索“短链接”，点击顶部的第一个应用“网址缩短” 步骤5图片 6.在输入框中粘贴网址，点击右边的“缩短”，得到下面出现的缩短后链接，复制它 步骤6图片 7.大功告成，现在就可以进入网盘，新建离线下载任务，粘贴刚得到的链接，进行离线下载了 看来速度还行 步骤7图片 PS：使用360云盘进行离线下载肯定会出现下面的情况，不需要担心，等到离线下载完成后文件大小会自动改变的 PS1图片 =============================================== 注意，离线下载完成后记得改文件名本文同样发布在卡饭上：http://bbs.kafan.cn/thread-1619457-1-1.html","categories":[{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"Youtube","slug":"Youtube","permalink":"https://xdh129.github.io/tags/Youtube/"},{"name":"下载","slug":"下载","permalink":"https://xdh129.github.io/tags/%E4%B8%8B%E8%BD%BD/"},{"name":"网盘","slug":"网盘","permalink":"https://xdh129.github.io/tags/%E7%BD%91%E7%9B%98/"},{"name":"视频","slug":"视频","permalink":"https://xdh129.github.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"转存","slug":"转存","permalink":"https://xdh129.github.io/tags/%E8%BD%AC%E5%AD%98/"}]},{"title":"已通关游戏列表","slug":"complete-the-game-list","date":"2013-08-25T08:49:50.000Z","updated":"2013-08-25T08:49:50.000Z","comments":true,"path":"2013/08/25/complete-the-game-list/","link":"","permalink":"https://xdh129.github.io/2013/08/25/complete-the-game-list/","excerpt":"","text":"博主家的电脑是一台古董机，因此很多游戏都玩不了/痛苦。但是自从有了云游戏，让博主的电脑玩上了许多原本因配置原因玩不了的游戏。废话不多说，下面列出我所有通关过的游戏： 1.双星物语2（本机）-APRG2.疯狂农场2（本机）-SLG PS：貌似有很多英文游戏都用这个译名，这个游戏的原名是Mania Farm 23.超级马里奥1（FC模拟器）-ACT4.孤岛惊魂3（云游戏）-FPS5.孤岛危机2（云游戏）-FPS6.植物大战僵尸（本机）-PUZ7.上古卷轴5（云游戏）-ARPG-未玩任何DLC-玩时已作弊:无敌+全技能+全技能点+各种物品、金钱get8.魔兽争霸3（本机）-RTS-神作，绝对经典9.泰坦尼克:宿命旅行（本机）-PUZ-这游戏不错！10. 放上古董机配置： AIDA64 检测报告： AIDA64 3.00.2578 Beta.htm================分隔线================ 另外，我的手机CPU是armv5te架构的，因此注定和这台古董机一样，同样是很多游戏都玩不了 已通关游戏列表：暂时木有，基本都只玩到一半 这里是手机详细配置：型号：ZTE-U880ECPU：Marvell PXA920H（armv5te）GPU：Vivante GC530RAM：436M ================分隔线================这里是博主未通关，觉得精品的游戏1.耻辱（在云游戏玩到一半，-玩到被自己的朋友背叛的剧情，被好心船夫送到某地-，结果存档不见了，不见了）2.狂野飙车6、7、8代 -手机（确实不错）","categories":[{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"云游戏","slug":"云游戏","permalink":"https://xdh129.github.io/tags/%E4%BA%91%E6%B8%B8%E6%88%8F/"},{"name":"游戏","slug":"游戏","permalink":"https://xdh129.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"AIDA64","slug":"AIDA64","permalink":"https://xdh129.github.io/tags/AIDA64/"},{"name":"armv5","slug":"armv5","permalink":"https://xdh129.github.io/tags/armv5/"},{"name":"低配机的愤怒","slug":"低配机的愤怒","permalink":"https://xdh129.github.io/tags/%E4%BD%8E%E9%85%8D%E6%9C%BA%E7%9A%84%E6%84%A4%E6%80%92/"},{"name":"低配置","slug":"低配置","permalink":"https://xdh129.github.io/tags/%E4%BD%8E%E9%85%8D%E7%BD%AE/"},{"name":"列表","slug":"列表","permalink":"https://xdh129.github.io/tags/%E5%88%97%E8%A1%A8/"},{"name":"梦想","slug":"梦想","permalink":"https://xdh129.github.io/tags/%E6%A2%A6%E6%83%B3/"},{"name":"通关","slug":"通关","permalink":"https://xdh129.github.io/tags/%E9%80%9A%E5%85%B3/"}]},{"title":"360云盘升级 超440GB永久免费+离线下载+文件加密+在线播放+无限分享流量+群共享+秒传","slug":"get-360-yunpan-storage-space","date":"2013-08-22T04:06:48.000Z","updated":"2013-08-22T04:06:48.000Z","comments":true,"path":"2013/08/22/get-360-yunpan-storage-space/","link":"","permalink":"https://xdh129.github.io/2013/08/22/get-360-yunpan-storage-space/","excerpt":"","text":"超过440G云盘免费永久空间领取教程： http://e.weibo.com/2420259703/A5B0QcQ29 360G地址：http://huodong.yunpan.360.cn/na360g 手机卫士5G+27G地址：http://bbs.360safe.com/thread-2210439-1-1.html 360搜索 36G地址： http://www.so.com/holiday/816.html =======================================================简单任务440G到手，如还需要更大免费空间 可以参加以下活动： 例如在360手机助手软件特权栏目中安装360一些移动端应用 也可以获取几G空间，做完之后 450G永久免费空间不是梦。还有安全卫士等级特权赠送云盘空间，目前一共累计赠送15G（各等级特权）以及云盘自身等级特权赠送空间，也是一共几十G 全部搞定后+每日抽奖空间 总计会达到500G+。还有一个1024G任务：http://huodong.yunpan.360.cn/此文转自：http://bbs.kafan.cn/thread-1616502-1-1.html","categories":[{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"360","slug":"360","permalink":"https://xdh129.github.io/tags/360/"},{"name":"云盘","slug":"云盘","permalink":"https://xdh129.github.io/tags/%E4%BA%91%E7%9B%98/"},{"name":"免费","slug":"免费","permalink":"https://xdh129.github.io/tags/%E5%85%8D%E8%B4%B9/"},{"name":"存储空间","slug":"存储空间","permalink":"https://xdh129.github.io/tags/%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4/"},{"name":"扩容","slug":"扩容","permalink":"https://xdh129.github.io/tags/%E6%89%A9%E5%AE%B9/"},{"name":"竞争","slug":"竞争","permalink":"https://xdh129.github.io/tags/%E7%AB%9E%E4%BA%89/"}]},{"title":"7.31-8.2 誓与作业一战！！！！","slug":"7-31-8-2-master-homework-battle","date":"2013-07-31T09:33:55.000Z","updated":"2013-07-31T09:33:55.000Z","comments":true,"path":"2013/07/31/7-31-8-2-master-homework-battle/","link":"","permalink":"https://xdh129.github.io/2013/07/31/7-31-8-2-master-homework-battle/","excerpt":"","text":"苦逼学生党8.3要去交作业啊啊啊啊啊啊啊啊，作业还差一大半啊啊啊，所以这几天一定要把作业全写完，即使是通宵我也不在乎啊/去死。。。 作业完成进度========complete homework 语文–通宵完成。。。 数学–两天搞定。。。 英语–花了一个下午。。。 终于写完了。。。 历史–借助网络的力量，N小时搞定。。呼呼 还好在交之前搞定了。。。不过这作业质量吗。。。就差得多了= =所以作业一定要提前写啊。。。反正迟早都要写的，不然拖到后面写都写不完啊。。。我就是一个惨痛的活生生的例子==================分隔线================== 8.3日及以后作业完成进度-HC 语文–写完鸟心情各种舒畅 数学–作业中最多的就是它了。。。真是让人痛苦 英语–某万恶的海报。。。。终于画完了 历史–两张卷子已搞定 物理–终于写完了，好多啊 ==================分隔线================== 完成作业后感言：–作业不要拖着写啊。。。不然你到假期还剩二十天左右的时候会很痛苦的","categories":[{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"去死吧作业","slug":"去死吧作业","permalink":"https://xdh129.github.io/tags/%E5%8E%BB%E6%AD%BB%E5%90%A7%E4%BD%9C%E4%B8%9A/"},{"name":"学生","slug":"学生","permalink":"https://xdh129.github.io/tags/%E5%AD%A6%E7%94%9F/"},{"name":"战斗","slug":"战斗","permalink":"https://xdh129.github.io/tags/%E6%88%98%E6%96%97/"}]},{"title":"关于7.28-29的爆吧","slug":"about-baidu-tieba-attack","date":"2013-07-30T13:56:23.000Z","updated":"2013-07-30T13:56:23.000Z","comments":true,"path":"2013/07/30/about-baidu-tieba-attack/","link":"","permalink":"https://xdh129.github.io/2013/07/30/about-baidu-tieba-attack/","excerpt":"","text":"首回合权志龙爆吧行动高潮已经散去，据不完全统计，截止7月29日上午09.45分，各俱乐部国家队共出动参战部队258万人次，其中李毅吧遥遥领先出动66万人次，其次皇家马德里：39万人次，巴塞罗那36万。拜仁慕尼黑28万。米兰双雄27万。切尔西15万。其他粉丝吧出动47万人次！这个数字超越了第二次世界大战德军闪击波兰和日本侵略中国的部队人数总和！共发帖1756万条。阵亡小号无数。感谢权志龙！让我们德比死敌空前的团结一致！敬礼！","categories":[{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"攻击","slug":"攻击","permalink":"https://xdh129.github.io/tags/%E6%94%BB%E5%87%BB/"},{"name":"明星","slug":"明星","permalink":"https://xdh129.github.io/tags/%E6%98%8E%E6%98%9F/"},{"name":"爆吧","slug":"爆吧","permalink":"https://xdh129.github.io/tags/%E7%88%86%E5%90%A7/"},{"name":"百度","slug":"百度","permalink":"https://xdh129.github.io/tags/%E7%99%BE%E5%BA%A6/"},{"name":"足球","slug":"足球","permalink":"https://xdh129.github.io/tags/%E8%B6%B3%E7%90%83/"}]},{"title":"信仰无国界！外国Fans绘制《刺客信条》图赏（慎入）","slug":"assassins-creed-gameparos","date":"2013-07-23T08:03:54.000Z","updated":"2013-07-23T08:03:54.000Z","comments":true,"path":"2013/07/23/assassins-creed-gameparos/","link":"","permalink":"https://xdh129.github.io/2013/07/23/assassins-creed-gameparos/","excerpt":"","text":"近来，国外一名叫做doubleleaf的《刺客信条》的忠实玩家创作了一组《刺客信条》游戏系列的████画作。从画作的内容看来，如果这位作者在中国，应该会被称作是“████”吧……画作的内容十分劲暴，恶搞的████趣味十足，作者更是画功深厚，用笔细腻，赶紧让我们来欣赏一下吧！ （来源：http://www.gamersky.com/news/201102/170433.shtml） =============以上为转载游民星空内容============= 这位作者画的图轻度不和谐，内带██，所以我在这里就不贴出那些奇怪的部分了。 我把图集打包了下来，上传到了网盘上，████自行观看吧（███，慎入）百度网盘下载链接：http://pan.baidu.com/share/link?shareid=1138159646&amp;uk=924176178(已失效) 作者：doubleleaf 作者网站：http://doubleleaf.deviantart.com/ bh_des_by_doubleleaf Malik_giving_a_wink_by_doubleleaf Altair_by_doubleleaf escape_mashaf_by_doubleleaf PS：画得真的不错啊，赞一个~","categories":[{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"刺客","slug":"刺客","permalink":"https://xdh129.github.io/tags/%E5%88%BA%E5%AE%A2/"},{"name":"刺客信条","slug":"刺客信条","permalink":"https://xdh129.github.io/tags/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1/"},{"name":"图集","slug":"图集","permalink":"https://xdh129.github.io/tags/%E5%9B%BE%E9%9B%86/"},{"name":"插画","slug":"插画","permalink":"https://xdh129.github.io/tags/%E6%8F%92%E7%94%BB/"}]},{"title":"感叹一下云游戏的陨落。。。","slug":"about-cloudunion","date":"2013-07-22T09:38:26.000Z","updated":"2013-07-22T09:38:26.000Z","comments":true,"path":"2013/07/22/about-cloudunion/","link":"","permalink":"https://xdh129.github.io/2013/07/22/about-cloudunion/","excerpt":"","text":"官网logo 云游戏，传说中中国最专业的云游戏平台“云联科技”。根据官方的介绍，通过“云游戏”这个平台，你根本无需下载，只需像看电影在线点播那样，稍等瞬间就开始在线玩体积超过10G的超大型3D游戏！而且即便你的电脑只有性能很一般的集成显卡，内存CPU硬盘空间神马的很吃紧，也能流畅地体验最新的/配置要求特别BT的3D新游戏，无需安装，无需配置，非常简单。可谓是低配置、怕麻烦玩家们的福音。 （此段文字引自异次元软件世界） 我曾经在云游戏中成功将耻辱，上古卷轴5，孤岛危机2和孤岛惊魂3通关。云游戏内游戏均限帧在25fps内，因此游戏的流畅度还是不错的，操作延迟也比较低。只是画面会受到网速波动的影响，时常有抖动的模糊现象出现。但是，这对于性能低的PC来说，都不是问题。云游戏服务器的配置也是非常不错的，以下附图。（PS：还有一张云游戏中运行街头霸王X铁拳内benchmark结果的图我找不到了 /捂脸） benchmark2 benchmark1 自从云游戏中某网游上架后（1月13日），引来了大量的用户，其中不乏各种学生，参观者，试玩者，一度导致服务器亚历山大，于是云游戏官方经常不得不以维护的名义关闭此游戏，以减轻压力。 但是在从6月28日后，云游戏官方客服通通消失了，与此同时也关闭了大量的服务器，据说是云联经营不善，濒临破产（未经证实） 来源：http://cio.it168.com/a2013/0711/1506/000001506270.shtml 唉，如今的云游戏，真是不如以前了。。","categories":[{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"云","slug":"云","permalink":"https://xdh129.github.io/tags/%E4%BA%91/"},{"name":"云游戏","slug":"云游戏","permalink":"https://xdh129.github.io/tags/%E4%BA%91%E6%B8%B8%E6%88%8F/"},{"name":"关闭","slug":"关闭","permalink":"https://xdh129.github.io/tags/%E5%85%B3%E9%97%AD/"},{"name":"游戏","slug":"游戏","permalink":"https://xdh129.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"分享一首歌 - 威风堂々","slug":"share-a-song-chivalry","date":"2013-07-21T03:54:10.000Z","updated":"2013-07-21T03:54:10.000Z","comments":true,"path":"2013/07/21/share-a-song-chivalry/","link":"","permalink":"https://xdh129.github.io/2013/07/21/share-a-song-chivalry/","excerpt":"","text":"这首歌的歌词虽然挺不和谐的。。不过听起来还是挺带感的。。赞一个。。 女声版：http://fc.5sing.com/8295696.html试听： Flash嵌入已失效 男声版：http://fc.5sing.com/9226352.html试听：Flash嵌入已失效","categories":[{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://xdh129.github.io/tags/%E5%88%86%E4%BA%AB/"},{"name":"日文","slug":"日文","permalink":"https://xdh129.github.io/tags/%E6%97%A5%E6%96%87/"},{"name":"歌曲","slug":"歌曲","permalink":"https://xdh129.github.io/tags/%E6%AD%8C%E6%9B%B2/"},{"name":"试听","slug":"试听","permalink":"https://xdh129.github.io/tags/%E8%AF%95%E5%90%AC/"}]},{"title":"世界，你好！","slug":"hello-world-wordpress","date":"2013-07-20T17:58:43.000Z","updated":"2013-07-20T17:58:43.000Z","comments":true,"path":"2013/07/21/hello-world-wordpress/","link":"","permalink":"https://xdh129.github.io/2013/07/21/hello-world-wordpress/","excerpt":"","text":"欢迎使用 WordPress。这是系统自动生成的演示文章。编辑或者删除它，然后开始您的博客！","categories":[{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://xdh129.github.io/tags/Hello-World/"},{"name":"WordPress","slug":"WordPress","permalink":"https://xdh129.github.io/tags/WordPress/"},{"name":"世界","slug":"世界","permalink":"https://xdh129.github.io/tags/%E4%B8%96%E7%95%8C/"},{"name":"你好","slug":"你好","permalink":"https://xdh129.github.io/tags/%E4%BD%A0%E5%A5%BD/"},{"name":"示例","slug":"示例","permalink":"https://xdh129.github.io/tags/%E7%A4%BA%E4%BE%8B/"}]}],"categories":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/categories/%E4%BD%9C%E4%B8%9A/"},{"name":"应用框架","slug":"应用框架","permalink":"https://xdh129.github.io/categories/%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"},{"name":"Pre-Blog","slug":"Pre-Blog","permalink":"https://xdh129.github.io/categories/Pre-Blog/"}],"tags":[{"name":"作业","slug":"作业","permalink":"https://xdh129.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"算法设计","slug":"算法设计","permalink":"https://xdh129.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"},{"name":"开发","slug":"开发","permalink":"https://xdh129.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"软件工程","slug":"软件工程","permalink":"https://xdh129.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Flutter","slug":"Flutter","permalink":"https://xdh129.github.io/tags/Flutter/"},{"name":"iOS","slug":"iOS","permalink":"https://xdh129.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"https://xdh129.github.io/tags/Android/"},{"name":"跨平台","slug":"跨平台","permalink":"https://xdh129.github.io/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"name":"调用","slug":"调用","permalink":"https://xdh129.github.io/tags/%E8%B0%83%E7%94%A8/"},{"name":"Java","slug":"Java","permalink":"https://xdh129.github.io/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://xdh129.github.io/tags/Kotlin/"},{"name":"Dart","slug":"Dart","permalink":"https://xdh129.github.io/tags/Dart/"},{"name":"停止","slug":"停止","permalink":"https://xdh129.github.io/tags/%E5%81%9C%E6%AD%A2/"},{"name":"日记","slug":"日记","permalink":"https://xdh129.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"更新","slug":"更新","permalink":"https://xdh129.github.io/tags/%E6%9B%B4%E6%96%B0/"},{"name":"软件","slug":"软件","permalink":"https://xdh129.github.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"Youtube","slug":"Youtube","permalink":"https://xdh129.github.io/tags/Youtube/"},{"name":"下载","slug":"下载","permalink":"https://xdh129.github.io/tags/%E4%B8%8B%E8%BD%BD/"},{"name":"网盘","slug":"网盘","permalink":"https://xdh129.github.io/tags/%E7%BD%91%E7%9B%98/"},{"name":"视频","slug":"视频","permalink":"https://xdh129.github.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"转存","slug":"转存","permalink":"https://xdh129.github.io/tags/%E8%BD%AC%E5%AD%98/"},{"name":"云游戏","slug":"云游戏","permalink":"https://xdh129.github.io/tags/%E4%BA%91%E6%B8%B8%E6%88%8F/"},{"name":"游戏","slug":"游戏","permalink":"https://xdh129.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"AIDA64","slug":"AIDA64","permalink":"https://xdh129.github.io/tags/AIDA64/"},{"name":"armv5","slug":"armv5","permalink":"https://xdh129.github.io/tags/armv5/"},{"name":"低配机的愤怒","slug":"低配机的愤怒","permalink":"https://xdh129.github.io/tags/%E4%BD%8E%E9%85%8D%E6%9C%BA%E7%9A%84%E6%84%A4%E6%80%92/"},{"name":"低配置","slug":"低配置","permalink":"https://xdh129.github.io/tags/%E4%BD%8E%E9%85%8D%E7%BD%AE/"},{"name":"列表","slug":"列表","permalink":"https://xdh129.github.io/tags/%E5%88%97%E8%A1%A8/"},{"name":"梦想","slug":"梦想","permalink":"https://xdh129.github.io/tags/%E6%A2%A6%E6%83%B3/"},{"name":"通关","slug":"通关","permalink":"https://xdh129.github.io/tags/%E9%80%9A%E5%85%B3/"},{"name":"360","slug":"360","permalink":"https://xdh129.github.io/tags/360/"},{"name":"云盘","slug":"云盘","permalink":"https://xdh129.github.io/tags/%E4%BA%91%E7%9B%98/"},{"name":"免费","slug":"免费","permalink":"https://xdh129.github.io/tags/%E5%85%8D%E8%B4%B9/"},{"name":"存储空间","slug":"存储空间","permalink":"https://xdh129.github.io/tags/%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4/"},{"name":"扩容","slug":"扩容","permalink":"https://xdh129.github.io/tags/%E6%89%A9%E5%AE%B9/"},{"name":"竞争","slug":"竞争","permalink":"https://xdh129.github.io/tags/%E7%AB%9E%E4%BA%89/"},{"name":"去死吧作业","slug":"去死吧作业","permalink":"https://xdh129.github.io/tags/%E5%8E%BB%E6%AD%BB%E5%90%A7%E4%BD%9C%E4%B8%9A/"},{"name":"学生","slug":"学生","permalink":"https://xdh129.github.io/tags/%E5%AD%A6%E7%94%9F/"},{"name":"战斗","slug":"战斗","permalink":"https://xdh129.github.io/tags/%E6%88%98%E6%96%97/"},{"name":"攻击","slug":"攻击","permalink":"https://xdh129.github.io/tags/%E6%94%BB%E5%87%BB/"},{"name":"明星","slug":"明星","permalink":"https://xdh129.github.io/tags/%E6%98%8E%E6%98%9F/"},{"name":"爆吧","slug":"爆吧","permalink":"https://xdh129.github.io/tags/%E7%88%86%E5%90%A7/"},{"name":"百度","slug":"百度","permalink":"https://xdh129.github.io/tags/%E7%99%BE%E5%BA%A6/"},{"name":"足球","slug":"足球","permalink":"https://xdh129.github.io/tags/%E8%B6%B3%E7%90%83/"},{"name":"刺客","slug":"刺客","permalink":"https://xdh129.github.io/tags/%E5%88%BA%E5%AE%A2/"},{"name":"刺客信条","slug":"刺客信条","permalink":"https://xdh129.github.io/tags/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1/"},{"name":"图集","slug":"图集","permalink":"https://xdh129.github.io/tags/%E5%9B%BE%E9%9B%86/"},{"name":"插画","slug":"插画","permalink":"https://xdh129.github.io/tags/%E6%8F%92%E7%94%BB/"},{"name":"云","slug":"云","permalink":"https://xdh129.github.io/tags/%E4%BA%91/"},{"name":"关闭","slug":"关闭","permalink":"https://xdh129.github.io/tags/%E5%85%B3%E9%97%AD/"},{"name":"分享","slug":"分享","permalink":"https://xdh129.github.io/tags/%E5%88%86%E4%BA%AB/"},{"name":"日文","slug":"日文","permalink":"https://xdh129.github.io/tags/%E6%97%A5%E6%96%87/"},{"name":"歌曲","slug":"歌曲","permalink":"https://xdh129.github.io/tags/%E6%AD%8C%E6%9B%B2/"},{"name":"试听","slug":"试听","permalink":"https://xdh129.github.io/tags/%E8%AF%95%E5%90%AC/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://xdh129.github.io/tags/Hello-World/"},{"name":"WordPress","slug":"WordPress","permalink":"https://xdh129.github.io/tags/WordPress/"},{"name":"世界","slug":"世界","permalink":"https://xdh129.github.io/tags/%E4%B8%96%E7%95%8C/"},{"name":"你好","slug":"你好","permalink":"https://xdh129.github.io/tags/%E4%BD%A0%E5%A5%BD/"},{"name":"示例","slug":"示例","permalink":"https://xdh129.github.io/tags/%E7%A4%BA%E4%BE%8B/"}]}